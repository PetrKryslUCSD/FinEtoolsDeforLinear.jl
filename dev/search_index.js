var documenterSearchIndex = {"docs":
[{"location":"man/types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"man/types.html#FEM-machines","page":"Types","title":"FEM machines","text":"","category":"section"},{"location":"man/types.html#Linear-deformation","page":"Types","title":"Linear deformation","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtoolsDeforLinear.DeforModelRedModule, FinEtoolsDeforLinear.FEMMDeforLinearBaseModule, FinEtoolsDeforLinear.FEMMDeforLinearModule, FinEtoolsDeforLinear.FEMMDeforWinklerModule, FinEtoolsDeforLinear.FEMMDeforLinearMSModule, FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule, FinEtoolsDeforLinear.FEMMDeforLinearNICEModule, FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtoolsDeforLinear.DeforModelRedModule.AbstractDeforModelRed","page":"Types","title":"FinEtoolsDeforLinear.DeforModelRedModule.AbstractDeforModelRed","text":"AbstractDeforModelRed\n\nAbstract type of model reduction for deformation analysis.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed1D","page":"Types","title":"FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed1D","text":"DeforModelRed1D <: AbstractDeforModelRed\n\nModel reduction for 1-D models.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed2DAxisymm","page":"Types","title":"FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed2DAxisymm","text":"DeforModelRed2DAxisymm <: AbstractDeforModelRed\n\nModel reduction for 2-D axially symmetric models.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed2DStrain","page":"Types","title":"FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed2DStrain","text":"DeforModelRed2DStrain <: AbstractDeforModelRed\n\nModel reduction for 2-D plane strain models.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed2DStress","page":"Types","title":"FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed2DStress","text":"DeforModelRed2DStress <: AbstractDeforModelRed\n\nModel reduction for 2-D plane stress models.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed3D","page":"Types","title":"FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed3D","text":"DeforModelRed3D <: AbstractDeforModelRed\n\nModel reduction for 3-D models.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.AbstractFEMMDeforLinear","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.AbstractFEMMDeforLinear","text":"AbstractFEMMDeforLinear <: AbstractFEMMBase\n\nAbstract type of FEMM for linear deformation.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearModule.FEMMDeforLinear","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearModule.FEMMDeforLinear","text":"FEMMDeforLinear{MR<:AbstractDeforModelRed,  S<:AbstractFESet, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinear\n\nClass for linear deformation finite element modeling machine.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearModule.FEMMDeforLinear-Union{Tuple{M}, Tuple{F}, Tuple{S}, Tuple{MR}, Tuple{Type{MR},IntegDomain{S,F},M}} where M<:AbstractMatDeforLinearElastic where F<:Function where S<:AbstractFESet where MR<:AbstractDeforModelRed","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearModule.FEMMDeforLinear","text":"FEMMDeforLinear(mr::Type{MR}, integdomain::IntegDomain{S, F}, material::M) where {MR<:AbstractDeforModelRed, S<:AbstractFESet, F<:Function, M<:AbstractMatDeforLinearElastic}\n\nConstructor of linear deformation finite element modeling machine.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforWinklerModule.FEMMDeforWinkler","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforWinklerModule.FEMMDeforWinkler","text":"FEMMDeforWinkler{S<:AbstractFESet, F<:Function} <: AbstractFEMM\n\nType for normal spring support  (Winkler).\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS","text":"AbstractFEMMDeforLinearMS <: AbstractFEMMDeforLinear\n\nAbstract type for mean-strain linear deformation FEMM.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearMSModule.FEMMDeforLinearMSH8","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearMSModule.FEMMDeforLinearMSH8","text":"FEMMDeforLinearMSH8{MR<:AbstractDeforModelRed, S<:FESetH8, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearMS\n\nType for mean-strain linear deformation FEMM based on eight-node hexahedral elements.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearMSModule.FEMMDeforLinearMST10","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearMSModule.FEMMDeforLinearMST10","text":"FEMMDeforLinearMST10{MR<:AbstractDeforModelRed, S<:FESetT10, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearMS\n\nType for mean-strain linear deformation FEMM based on 10-node tetrahedral elements.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule.FEMMDeforSurfaceDamping","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule.FEMMDeforSurfaceDamping","text":"FEMMDeforSurfaceDamping{S<:AbstractFESet, F<:Function} <: AbstractFEMM\n\nType for surface damping model.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE","text":"AbstractFEMMDeforLinearNICE <: AbstractFEMMDeforLinear\n\nAbstract FEMM type for Nodally Integrated Continuum Elements (NICE).\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.FEMMDeforLinearNICEH8","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.FEMMDeforLinearNICEH8","text":"FEMMDeforLinearNICEH8{MR<:AbstractDeforModelRed, S<:FESetH8, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearNICE\n\nFEMM type for Nodally Integrated Continuum Elements (NICE) based on the eight-node hexahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.FEMMDeforLinearNICET4","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.FEMMDeforLinearNICET4","text":"FEMMDeforLinearNICET4{MR<:AbstractDeforModelRed, S<:FESetT4, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearNICE\n\nFEMM type for Nodally Integrated Continuum Elements (NICE) based on the 4-node tetrahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE","text":"AbstractFEMMDeforLinearESNICE <: AbstractFEMMDeforLinear\n\nAbstract FEMM type for Nodally Integrated Continuum Elements (NICE) with energy-sampling stabilization.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.FEMMDeforLinearESNICEH8","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.FEMMDeforLinearESNICEH8","text":"FEMMDeforLinearESNICEH8{MR<:AbstractDeforModelRed, S<:FESetH8, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearESNICE\n\nFEMM type for Nodally Integrated Continuum Elements (NICE) based on the 8-node hexahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.FEMMDeforLinearESNICET4","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.FEMMDeforLinearESNICET4","text":"FEMMDeforLinearESNICET4{MR<:AbstractDeforModelRed, S<:FESetT4, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearESNICE\n\nFEMM type for Nodally Integrated Continuum Elements (NICE) based on the 4-node tetrahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Material-models","page":"Types","title":"Material models","text":"","category":"section"},{"location":"man/types.html#Material-for-deformation,-base-functionality","page":"Types","title":"Material for deformation, base functionality","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtoolsDeforLinear.MatDeforModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforModule.AbstractMatDefor","page":"Types","title":"FinEtoolsDeforLinear.MatDeforModule.AbstractMatDefor","text":"AbstractMatDefor\n\nAbstract type that represents deformable materials.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Material-models-for-elasticity","page":"Types","title":"Material models for elasticity","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtoolsDeforLinear.MatDeforLinearElasticModule, FinEtoolsDeforLinear.MatDeforElastIsoModule, FinEtoolsDeforLinear.MatDeforElastOrthoModule,]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforLinearElasticModule.AbstractMatDeforLinearElastic","page":"Types","title":"FinEtoolsDeforLinear.MatDeforLinearElasticModule.AbstractMatDeforLinearElastic","text":"AbstractMatDeforLinearElastic <: AbstractMatDefor\n\nAbstract Linear Elasticity  material.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso{MR<:AbstractDeforModelRed, MTAN<:Function, MUPD<:Function, MTHS<:Function} <: AbstractMatDeforLinearElastic\n\nLinear isotropic elasticity  material.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed1D},Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed1D}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 1D models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed2DAxisymm},Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed2DAxisymm}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 2D axially symmetric models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed2DStrain},Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed2DStrain}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 2D plane strain models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed2DStress},Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed2DStress}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 2D plane stress models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed3D},Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed3D}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 3D models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Union{Tuple{MR}, Tuple{Type{MR},Float64,Float64}} where MR","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{MR}, E::FFlt, nu::FFlt) where {MR}\n\nCreate isotropic elastic material with default mass density and thermal expansion.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho{MR<:AbstractDeforModelRed,  MTAN<:Function, MUPD<:Function, MTHS<:Function} <: AbstractMatDeforLinearElastic\n\nLinear orthotropic elasticity  material.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Tuple{Type{DeforModelRed2DAxisymm},Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{DeforModelRed2DAxisymm}, mass_density::FFlt,\n\tE1::FFlt, E2::FFlt, E3::FFlt, nu12::FFlt, nu13::FFlt, nu23::FFlt,\n\tG12::FFlt, G13::FFlt, G23::FFlt, CTE1::FFlt, CTE2::FFlt, CTE3::FFlt)\n\nCreate elastic orthotropic material for 2D axially symmetric models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Tuple{Type{DeforModelRed2DStrain},Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{DeforModelRed2DStrain}, mass_density::FFlt,\n\tE1::FFlt, E2::FFlt, E3::FFlt, nu12::FFlt, nu13::FFlt, nu23::FFlt,\n\tG12::FFlt, G13::FFlt, G23::FFlt, CTE1::FFlt, CTE2::FFlt, CTE3::FFlt)\n\nCreate elastic orthotropic material for 2D plane strain models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Tuple{Type{DeforModelRed2DStress},Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{DeforModelRed2DStress}, mass_density::FFlt,\n\tE1::FFlt, E2::FFlt, E3::FFlt, nu12::FFlt, nu13::FFlt, nu23::FFlt,\n\tG12::FFlt, G13::FFlt, G23::FFlt, CTE1::FFlt, CTE2::FFlt, CTE3::FFlt)\n\nCreate elastic orthotropic material for 2D plane stress models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Tuple{Type{DeforModelRed3D},Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{DeforModelRed3D}, mass_density::FFlt,\n\tE1::FFlt, E2::FFlt, E3::FFlt, nu12::FFlt, nu13::FFlt, nu23::FFlt,\n\tG12::FFlt, G13::FFlt, G23::FFlt, CTE1::FFlt, CTE2::FFlt, CTE3::FFlt)\n\nCreate elastic orthotropic material for 3D models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Union{Tuple{MR}, Tuple{Type{MR},Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64}} where MR","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{MR}, E1::FFlt, E2::FFlt, E3::FFlt,\nnu12::FFlt, nu13::FFlt, nu23::FFlt,\nG12::FFlt, G13::FFlt, G23::FFlt) where {MR}\n\nCreate elastic orthotropic material.\n\nConvenience version with only the specification of the elastic properties.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Union{Tuple{MR}, Tuple{Type{MR},Float64,Float64,Float64,Float64}} where MR","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{MR}, mass_density::FFlt,  E::FFlt, nu::FFlt, CTE::FFlt) where {MR}\n\nCreate elastic orthotropic material which is really isotropic.\n\nConvenience version with only the specification of the elastic and thermal expansion properties.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Union{Tuple{MR}, Tuple{Type{MR},Float64,Float64}} where MR","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{MR}, E::FFlt, nu::FFlt) where {MR}\n\nCreate elastic orthotropic material which is really isotropic.\n\nConvenience version with only the specification of the elastic properties.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"man/functions.html#FEM-machines","page":"Functions","title":"FEM machines","text":"","category":"section"},{"location":"man/functions.html#Linear-deformation","page":"Functions","title":"Linear deformation","text":"","category":"section"},{"location":"man/functions.html#Model-reduction-types","page":"Functions","title":"Model reduction types","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.DeforModelRedModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.Blmat!-Tuple{Type{DeforModelRed1D},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.Blmat!","text":"Blmat!(MR::Type{DeforModelRed1D}, B::FFltMat,\n  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)\n\nCompute the strain-displacement matrix for a one-manifold element.\n\nCompute the linear, displacement independent, strain-displacement matrix for a one-manifold element.   The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim <= 3), and mdim = number of manifold dimensions (here mdim == 1).\n\nOutput\n\nB = strain-displacement matrix, where  size(B) = (nstressstrain,nnodes*dim); here nstressstrain= number of strains, dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element. The strain components are ordered as shown  in stresscomponentmap. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.Blmat!-Tuple{Type{DeforModelRed2DAxisymm},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.Blmat!","text":"Blmat!(MR::Type{DeforModelRed2DAxisymm}, B::FFltMat,\n  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)\n\nCompute the strain-displacement matrix for a two-manifold element for axially symmetric models.\n\nCompute the linear, displacement independent, strain-displacement matrix for a two-manifold element in axially-symmetric setting.   The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim <= 3), and mdim = number of manifold dimensions (here mdim == 2).\n\nOutput\n\nB = strain-displacement matrix, where  size(B) = (nstressstrain,nnodes*dim); here nstressstrain= number of strains, dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element. The strain components are ordered as shown  in stresscomponentmap. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.Blmat!-Tuple{Type{DeforModelRed2DStrain},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.Blmat!","text":"Blmat!(MR::Type{DeforModelRed2DStrain}, B::FFltMat,\n  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)\n\nCompute the strain-displacement matrix for a two-manifold element for plane-strain models.\n\nCompute the linear, displacement independent, strain-displacement matrix for a two-manifold element in plane-strain setting.   The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim <= 3), and mdim = number of manifold dimensions (here mdim == 2).\n\nOutput\n\nB = strain-displacement matrix, where  size(B) = (nstressstrain,nnodes*dim); here nstressstrain= number of strains, dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element. The strain components are ordered as shown  in stresscomponentmap. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.Blmat!-Tuple{Type{DeforModelRed2DStress},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.Blmat!","text":"Blmat!(MR::Type{DeforModelRed2DStress}, B::FFltMat,\n  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)\n\nCompute the strain-displacement matrix for a two-manifold element for plane-stress models.\n\nCompute the linear, displacement independent, strain-displacement matrix for a two-manifold element in plane-stress setting.   The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim <= 3), and mdim = number of manifold dimensions (here mdim == 2).\n\nOutput\n\nB = strain-displacement matrix, where  size(B) = (nstressstrain,nnodes*dim); here nstressstrain= number of strains, dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element. The strain components are ordered as shown  in stresscomponentmap. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.Blmat!-Tuple{Type{DeforModelRed3D},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.Blmat!","text":"Blmat!(MR::Type{DeforModelRed3D}, B::FFltMat,\n  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)\n\nCompute the strain-displacement matrix for a three-manifold element.\n\nCompute the linear, displacement independent, strain-displacement matrix for a three-manifold element.   The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim == 3), and mdim = number of manifold dimensions (here mdim == 3).\n\nOutput\n\nB = strain-displacement matrix, where  size(B) = (nstressstrain,nnodes*dim); here nstressstrain= number of strains, dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element. The strain components are ordered as shown  in stresscomponentmap. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.divmat-Tuple{Type{DeforModelRed3D},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.divmat","text":"divmat(MR::Type{DeforModelRed3D}, N::FFltMat, gradN::FFltMat, c::FFltMat)\n\nCompute the displacement divergence matrix for a three-manifold element.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim == 3), and mdim = number of manifold dimensions (here mdim == 3).\n\nOutput\n\ndivmat = displacement divergence matrix, where  size(divmat) = (1,nnodes*dim); here dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element.  The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.nstressstrain-Tuple{Type{DeforModelRed1D}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.nstressstrain","text":"nstressstrain(::Type{AbstractDeforModelRed})::FInt\n\nReturn the number of stress components involved in the balance equation (and how many strain components) are there for each model reduction type?\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.nthermstrain-Tuple{Type{DeforModelRed1D}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.nthermstrain","text":"nthermstrain(::Type{DeforModelRed1D})::FInt\n\nHow many thermal strain components are there for each model reduction type?\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.stresscomponentmap-Tuple{Type{DeforModelRed1D}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.stresscomponentmap","text":"stresscomponentmap(::Type{DeforModelRed1D})\n\nConstruct a dictionary to map from stress-component symbols to indexes.\n\nExample\n\nWhich component of the stress vector is for instance sigma_x? Do\n\njulia> comp = stresscomponentmap(DeforModelRed1D)\nDict{Symbol,Int64} with 2 entries:\n  :xx => 1\n  :x  => 1\n\njulia>\n\njulia> comp[:x]\n1\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.vgradmat-Tuple{Type{DeforModelRed3D},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.vgradmat","text":"vgradmat(MR::Type{DeforModelRed3D}, N::FFltMat, gradN::FFltMat, c::FFltMat)\n\nCompute the matrix of displacement gradient in vector form for a three-manifold element.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim == 3), and mdim = number of manifold dimensions (here mdim == 3).\n\nOutput\n\nvgradm = strain-displacement matrix, where  size(divmat) = (1,nnodes*dim); here dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element.  The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Base-functionality:-Interior","page":"Functions","title":"Base functionality: Interior","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.FEMMDeforLinearBaseModule, FinEtoolsDeforLinear.FEMMDeforLinearModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FEMM}, Tuple{FEMM,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any}, Tuple{FEMM,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any,Any}} where F<:Function where T<:Number where FEMM<:AbstractFEMMDeforLinear","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::AbstractFEMMDeforLinear,\n  geom::NodalField{FFlt},  u::NodalField{T},\n  dT::NodalField{FFlt},\n  felist::FIntVec,\n  inspector::F,  idat, quantity=:Cauchy;\n  context...) where {T<:Number, F<:Function}\n\nInspect integration point quantities.\n\ngeom - reference geometry field\nu - displacement field\ndT - temperature difference field\nfelist - indexes of the finite elements that are to be inspected:    The fes to be included are: fes[felist].\ncontext    - structure: see the update!() method of the material.\ninspector - functionwith the signature       idat = inspector(idat, j, conn, x, out, loc);  where   idat - a structure or an array that the inspector may          use to maintain some state,  for instance minimum or maximum of          stress, j is the element number, conn is the element connectivity,          out is the output of the update!() method,  loc is the location          of the integration point in the reference configuration.\n\nReturn\n\nThe updated inspector data is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.infsup_gh-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.infsup_gh","text":"infsup_gh(self::AbstractFEMMDeforLinear, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the norm of the divergence of the displacement.\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.infsup_sh-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.infsup_sh","text":"infsup_sh(self::AbstractFEMMDeforLinear, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the seminorm of the displacement (square root of the sum of the squares of the derivatives of the components of displacement).\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.mass-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.mass","text":"mass(self::AbstractFEMMDeforLinear,  assembler::A,\n  geom::NodalField{FFlt},\n  u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the consistent mass matrix\n\nThis is a general routine for the abstract linear-deformation  FEMM.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness","text":"nzebcloadsstiffness(self::AbstractFEMMDeforLinear,  assembler::A,\n  geom::NodalField{FFlt},\n  u::NodalField{T}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute load vector for nonzero EBC for fixed displacement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinear, assembler::A,\n      geom::NodalField{FFlt},\n      u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.thermalstrainloads-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T},NodalField{Float64}}} where T<:Number where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.thermalstrainloads","text":"thermalstrainloads(self::AbstractFEMMDeforLinear, assembler::A,\n    geom::NodalField{FFlt}, u::NodalField{T},\n    dT::NodalField{FFlt}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute the thermal-strain load vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Base-functionality:-Boundary","page":"Functions","title":"Base functionality: Boundary","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.FEMMDeforWinklerModule, FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforWinklerModule.surfacenormalspringstiffness-Union{Tuple{T}, Tuple{A}, Tuple{FEMMDeforWinkler,A,NodalField{Float64},NodalField{T},Float64,SurfaceNormal}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforWinklerModule.surfacenormalspringstiffness","text":"surfacenormalspringstiffness(self::FEMMDeforWinkler, assembler::A,\n    geom::NodalField{FFlt}, u::NodalField{T},\n    springconstant::FFlt, surfacenormal::SurfaceNormal) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the stiffness matrix of surface normal spring.\n\nRationale: consider continuously distributed springs between the surface of the solid body and the 'ground', in the direction normal to the surface. If the spring coefficient becomes large, we have an approximate method of enforcing the normal displacement to the surface.gas\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule.dampingABC-Union{Tuple{T2}, Tuple{T1}, Tuple{A}, Tuple{FEMMDeforSurfaceDamping,A,NodalField{Float64},NodalField{T1},T2,SurfaceNormal}} where T2<:Number where T1<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule.dampingABC","text":"dampingABC(self::FEMMDeforSurfaceDamping, assembler::A,\n              geom::NodalField{FFlt}, u::NodalField{T1},\n              impedance::T2, surfacenormal::SurfaceNormal) where {A<:AbstractSysmatAssembler, T1<:Number, T2<:Number}\n\nCompute the damping matrix associated with absorbing boundary conditions (ABC) representation of the effect of infinite extent of inviscid fluid next to the surface.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Simple-FE-models","page":"Functions","title":"Simple FE models","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.FEMMDeforLinearModule, FinEtoolsDeforLinear.FEMMDeforWinklerModule,  FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule, ]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Advanced-FE-models","page":"Functions","title":"Advanced FE models","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.FEMMDeforLinearMSModule, FinEtoolsDeforLinear.FEMMDeforLinearNICEModule, FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F,NodalField{Float64}}} where F<:FEMMDeforLinearMSH8","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F,NodalField{Float64}}} where F<:FEMMDeforLinearMST10","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any,Any}} where F<:Function where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::FEMMDeforLinear,      geom::NodalField{FFlt},  u::NodalField{T},      dT::NodalField{FFlt},      felist::FIntVec,      inspector::F,  idat, quantity=:Cauchy;      context...) where {T<:Number, F<:Function}\n\nInspect integration point quantities.\n\nArguments\n\ngeom - reference geometry field\nu - displacement field\ndT - temperature difference field\nfelist - indexes of the finite elements that are to be inspected:   The fes to be included are: fes[felist].\ncontext    - structure: see the update!() method of the material.\ninspector - functionwith the signature      idat = inspector(idat, j, conn, x, out, loc); where  idat - a structure or an array that the inspector may         use to maintain some state,  for instance minimum or maximum of         stress, j is the element number, conn is the element connectivity,         out is the output of the update!() method,  loc is the location         of the integration point in the reference configuration.\n\nReturn\n\nThe updated inspector data is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness","text":"nzebcloadsstiffness(self::AbstractFEMMDeforLinear,  assembler::A,   geom::NodalField{FFlt},   u::NodalField{T}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute load vector for nonzero EBC for fixed displacement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearMS, assembler::A,       geom::NodalField{FFlt},       u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearMSModule.infsup_gh-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearMSModule.infsup_gh","text":"infsup_gh(self::AbstractFEMMDeforLinearMS, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the norm of the divergence of the displacement.\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearMSModule.infsup_sh-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearMSModule.infsup_sh","text":"infsup_sh(self::AbstractFEMMDeforLinearMS, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the seminorm of the displacement (square root of the sum of the squares of the derivatives of the components of displacement).\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F,NodalField{Float64}}} where F<:FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness","text":"nzebcloadsstiffness(self::AbstractFEMMDeforLinear,  assembler::A,   geom::NodalField{FFlt},   u::NodalField{T}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute load vector for nonzero EBC for fixed displacement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearNICE, assembler::A,\n  geom::NodalField{FFlt},\n  u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE,NodalField{Float64},NodalField{T}}} where T<:Number","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearNICE, geom::NodalField{FFlt},  u::NodalField{T}) where {T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F,NodalField{Float64}}} where F<:FEMMDeforLinearESNICEH8","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::F,  geom::NodalField{FFlt}) where {F<:FEMMDeforLinearESNICEH8}\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F,NodalField{Float64}}} where F<:FEMMDeforLinearESNICET4","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::F,  geom::NodalField{FFlt}) where {F<:FEMMDeforLinearESNICET4}\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any,Any}} where F<:Function where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::AbstractFEMMDeforLinearESNICE, geom::NodalField{FFlt},  u::NodalField{T}, dT::NodalField{FFlt}, felist::FIntVec, inspector::F,  idat, quantity=:Cauchy; context...) where {T<:Number, F<:Function}\n\nInspect integration point quantities.\n\nArguments\n\ngeom - reference geometry field\nu - displacement field\ndT - temperature difference field\nfelist - indexes of the finite elements that are to be inspected:   The fes to be included are: fes[felist].\ncontext    - structure: see the update!() method of the material.\ninspector - functionwith the signature      idat = inspector(idat, j, conn, x, out, loc); where  idat - a structure or an array that the inspector may         use to maintain some state,  for instance minimum or maximum of         stress, j is the element number, conn is the element connectivity,         out is the output of the update!() method,  loc is the location         of the integration point in the reference configuration.\n\nReturn\n\nThe updated inspector data is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness","text":"nzebcloadsstiffness(self::AbstractFEMMDeforLinear,  assembler::A,   geom::NodalField{FFlt},   u::NodalField{T}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute load vector for nonzero EBC for fixed displacement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearESNICE, assembler::A,\n  geom::NodalField{FFlt},\n  u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.infsup_gh-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.infsup_gh","text":"infsup_gh(self::AbstractFEMMDeforLinearESNICE, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the norm of the divergence of the displacement.\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.infsup_sh-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.infsup_sh","text":"infsup_sh(self::AbstractFEMMDeforLinearESNICE, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the seminorm of the displacement (square root of the sum of the squares of the derivatives of the components of displacement).\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Algorithms","page":"Functions","title":"Algorithms","text":"","category":"section"},{"location":"man/functions.html#Linear-deformation-2","page":"Functions","title":"Linear deformation","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.AlgoDeforLinearModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.exportdeformation-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.exportdeformation","text":"AlgoDeforLinearModule.exportdeformation(modeldata::FDataDict)\n\nAlgorithm for exporting of the deformation for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field, or\n\"us\" = array of  tuples (name, displacement field)\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = array of data dictionaries, one for       each exported file. The data is stored with the keys:\n\"file\" - names of exported file\n\"field\" - nodal or elemental field\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.exportmode-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.exportmode","text":"AlgoDeforLinearModule.exportmode(modeldata::FDataDict)\n\nAlgorithm for exporting of the mmode shape for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field\n\"W\" = Computed free-vibration eigenvectors, neigvs columns\n\"omega\" =  Computed free-vibration angular frequencies, array of length neigvs\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\"mode\" = which mode should be visualized?\n\"component\" = which component of the quantity?\n\"outputcsys\" = output coordinate system\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = see exportdeformation()\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.exportstress-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.exportstress","text":"AlgoDeforLinearModule.exportstress(modeldata::FDataDict)\n\nAlgorithm for exporting of the stress for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\"quantity\" = quantity to be exported (default :Cauchy)\n\"component\" = which component of the quantity?\n\"outputcsys\" = output coordinate system\n\"inspectormeth\" = inspector method to pass to inspectintegpoints()\n\"extrap\" = method for extrapolating from the quadrature points to the nodes within one element\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = array of data dictionaries, one for       each exported file. The data is stored with the keys:\n\"file\" - name of exported file\n\"field\" - nodal field\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.exportstresselementwise-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.exportstresselementwise","text":"AlgoDeforLinearModule.exportstresselementwise(modeldata::FDataDict)\n\nAlgorithm for exporting of the elementwise stress for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\"quantity\" = quantity to be exported (default :Cauchy)\n\"component\" = which component of the quantity?\n\"outputcsys\" = output coordinate system\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = array of data dictionaries, one for       each exported file. The data is stored with the keys:\n\"file\" - name of exported file\n\"field\" - elemental field\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.linearstatics-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.linearstatics","text":"AlgoDeforLinearModule.linearstatics(modeldata::FDataDict)\n\nAlgorithm for static linear deformation (stress) analysis.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"essential_bcs\" = array of essential boundary condition dictionaries\n\"traction_bcs\" = array of traction boundary condition dictionaries\n\"temperature_change\" = dictionary of data for temperature change\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element model machine (mandatory);\n\nFor essential boundary conditions (optional) each dictionary would hold\n\n\"displacement\" = fixed (prescribed) displacement (scalar),  or         a function with signature function w = f(x).         If this value is not given, zero displacement is assumed.\n\"component\" = which component is prescribed  (1, 2, 3)?\n\"node_list\" = list of nodes on the boundary to which the condition applies         (mandatory)\n\nFor traction boundary conditions (optional) each dictionary would hold key-value pairs\n\n\"femm\" = finite element model machine (mandatory);\n\"traction_vector\" = traction vector,  either  a constant numerical   vector, or  a function to be used to construct a ForceIntensity   object, or it could be the ForceIntensity object itself.\n\nOutput\n\nmodeldata = the dictionary on input is augmented with the keys\n\n\"geom\" = the nodal field that is the geometry\n\"u\" = the nodal field that is the computed displacement\n\"temp\" = the nodal field that is the temperature change\n\"work\" = work of the applied loads\n\"timing\" = dictionary with timing results\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.modal-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.modal","text":"AlgoDeforLinearModule.modal(modeldata::FDataDict)\n\nModal (free-vibration) analysis solver.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"essential_bcs\" = array of essential boundary condition dictionaries\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nFor essential boundary conditions (optional) each dictionary would hold\n\n\"displacement\" = fixed (prescribed) displacement (scalar): only zero     displacement is  allowed for modal analysis.\n\"component\" = which component is prescribed  (1, 2, 3)?\n\"node_list\" = list of nodes on the boundary to which the condition applies         (mandatory)\n\nControl parameters:\n\n\"neigvs\" = number of eigenvalues/eigenvectors to compute\n\"omega_shift\"= angular frequency shift for mass shifting\n\"use_lumped_mass\" = true or false?  (Default is false: consistent mass)\n\nOutput\n\nmodeldata= the dictionary on input is augmented with\n\n\"geom\" = the nodal field that is the geometry\n\"u\" = the nodal field that is the computed displacement\n\"neigvs\" = Number of computed eigenvectors\n\"W\" = Computed eigenvectors, neigvs columns\n\"omega\" =  Computed angular frequencies, array of length neigvs\n\"raw_eigenvalues\" = Raw computed eigenvalues\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.ssit-Tuple{Any,Any}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.ssit","text":"ssit(K, M; nev::Int=6, evshift::FFlt = 0.0,\n    v0::FFltMat = Array{FFlt}(0, 0),\n    tol::FFlt = 1.0e-3, maxiter::Int = 300, verbose::Bool=false)\n\nSubspace  Iteration (block inverse power) method.\n\nBlock inverse power method for k smallest eigenvalues of the generalized eigenvalue problem            K*v= lambda*M*v\n\nArguments\n\nK =  square symmetric stiffness matrix (if necessary mass-shifted),\nM =  square symmetric mass matrix,\n\nKeyword arguments\n\nv0 =  initial guess of the eigenvectors (for instance random),\nnev = the number of eigenvalues sought\ntol = relative tolerance on the eigenvalue, expressed in terms of norms of the     change of the eigenvalue estimates from iteration to iteration.\nmaxiter =  maximum number of allowed iterations\nwithrr = with Rayleigh-Ritz problem solved to improve the subspace?  (default   is false)\nverbose = verbose? (default is false)\n\nOutput\n\nlabm = computed eigenvalues,\nv = computed eigenvectors,\nnconv = number of converged eigenvalues\nniter = number of iterations taken\nnmult = ignore this output\nlamberr = eigenvalue errors, defined as  normalized  differences  of   successive  estimates of the eigenvalues\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Material-models","page":"Functions","title":"Material models","text":"","category":"section"},{"location":"man/functions.html#Material-for-deformation,-base-functionality","page":"Functions","title":"Material for deformation, base functionality","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.MatDeforModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.dett-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.dett","text":"dett(::Type{DeforModelRed2DStrain},  C::FMat{T}) where {T}\n\nCompute the determinant of a general square matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.dett-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.dett","text":"dett(::Type{DeforModelRed3D},  C::FMat{T}) where {T}\n\nCompute the determinant of a general square matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.rotstressvec!-Union{Tuple{T}, Tuple{Type{DeforModelRed1D},Array{T,1},Array{T,1},Union{Array{T,2}, LinearAlgebra.Transpose{T,Array{T,2}}} where T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.rotstressvec!","text":"rotstressvec!(::Type{DeforModelRed1D},  outstress::FVec{T},  instress::FVec{T},  Rm::_RotationMatrix) where {T}\n\nRotate the stress vector by the supplied rotation matrix.\n\nCalculate the rotation of the stress vector to the 'bar' coordinate system given by the columns of the rotation matrix Rm.\n\noutstress = output stress vector, overwritten inside\ninstress = input stress vector\nRm = columns are components of 'bar' basis vectors on the 'plain'    basis vectors\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.rotstressvec!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DAxisymm},Array{T,1},Array{T,1},Union{Array{T,2}, LinearAlgebra.Transpose{T,Array{T,2}}} where T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.rotstressvec!","text":"rotstressvec!(::Type{DeforModelRed2DAxisymm},  outstress::FVec{T},  instress::FVec{T},  Rm::_RotationMatrix) where {T}\n\nRotate the stress vector by the supplied rotation matrix.\n\nCalculate the rotation of the stress vector to the 'bar' coordinate system given by the columns of the rotation matrix Rm.\n\noutstress = output stress vector, overwritten inside\ninstress = input stress vector\nRm = columns are components of 'bar' basis vectors on the 'plain'    basis vectors\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.rotstressvec!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,1},Array{T,1},Union{Array{T,2}, LinearAlgebra.Transpose{T,Array{T,2}}} where T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.rotstressvec!","text":"rotstressvec!(::Type{DeforModelRed2DStrain},  outstress::FVec{T},  instress::FVec{T},  Rm::_RotationMatrix) where {T}\n\nRotate the stress vector by the supplied rotation matrix.\n\nCalculate the rotation of the stress vector to the 'bar' coordinate system given by the columns of the rotation matrix Rm.\n\noutstress = output stress vector, overwritten inside\ninstress = input stress vector\nRm = columns are components of 'bar' basis vectors on the 'plain'    basis vectors\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.rotstressvec!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStress},Array{T,1},Array{T,1},Union{Array{T,2}, LinearAlgebra.Transpose{T,Array{T,2}}} where T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.rotstressvec!","text":"rotstressvec!(::Type{DeforModelRed2DStress},  outstress::FVec{T},  instress::FVec{T},  Rm::_RotationMatrix) where {T}\n\nRotate the stress vector by the supplied rotation matrix.\n\nCalculate the rotation of the stress vector to the 'bar' coordinate system given by the columns of the rotation matrix Rm.\n\noutstress = output stress vector, overwritten inside\ninstress = input stress vector\nRm = columns are components of 'bar' basis vectors on the 'plain'    basis vectors\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.rotstressvec!-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,1},Array{T,1},Union{Array{T,2}, LinearAlgebra.Transpose{T,Array{T,2}}} where T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.rotstressvec!","text":"rotstressvec!(::Type{DeforModelRed3D},  outstress::FVec{T},  instress::FVec{T}, Rm::_RotationMatrix) where {T}\n\nRotate the stress vector by the supplied rotation matrix.\n\nCalculate the rotation of the stress vector to the 'bar' coordinate system given by the columns of the rotation matrix Rm.\n\noutstress = output stress vector, overwritten inside\ninstress = input stress vector\nRm = columns are components of 'bar' basis vectors on the 'plain'    basis vectors\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainttov!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,1},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainttov!","text":"strainttov!(::Type{DeforModelRed2DStrain}, v::FVec{T}, t::FMat{T}) where {T}\n\nConvert a symmetric matrix of 2x2 strain components  into a 3-component vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainttov!-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,1},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainttov!","text":"strainttov!(::Type{DeforModelRed3D}, v::FVec{T}, t::FMat{T}) where {T}\n\nConvert a symmetric matrix of 3x3 strain components  into a 6-component vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvdet-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvdet","text":"strainvdet(::Type{DeforModelRed2DStrain},  Cv::FVec{T}) where {T}\n\nCompute the determinant of a symmetric strain-like square matrix represented as a vector. Remember that the shear strain components are twice the entries of the matrix representation.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvdet-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvdet","text":"strainvdet(::Type{DeforModelRed3D},  Cv::FVec{T}) where {T}\n\nCompute the determinant of a symmetric strain-like square matrix represented as a vector. Remember that the shear strain components are twice the entries of the matrix representation.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,2},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvtot!","text":"strainvtot!(::Type{DeforModelRed2DStrain}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a strain 3-vector to a  matrix of 2x2 strain components (symmetric tensor).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,2},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvtot!","text":"strainvtot!(::Type{DeforModelRed3D}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a strain 3-vector to a  matrix of 2x2 strain components (symmetric tensor).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvtr-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvtr","text":"strainvtr(::Type{DeforModelRed2DStrain},  Cv::FVec{T}) where {T}\n\nCompute the trace of a symmetric strain-like square matrix represented as a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvtr-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvtr","text":"strainvtr(::Type{DeforModelRed3D},  Cv::FVec{T}) where {T}\n\nCompute the trace of a symmetric strain-like square matrix represented as a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressttov!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,1},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressttov!","text":"stressttov!(::Type{DeforModelRed2DStrain}, v::FVec{T}, t::FMat{T}) where {T}\n\nConvert a symmetric matrix of 2x2 stress components to a 3-component vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressttov!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStress},Array{T,1},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressttov!","text":"stressttov!(::Type{DeforModelRed2DStress}, v::FVec{T}, t::FMat{T}) where {T}\n\nConvert a symmetric matrix of 2x2 stress components to a 3-component vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressttov!-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,1},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressttov!","text":"stressttov!(::Type{DeforModelRed3D}, v::FVec{T}, t::FMat{T}) where {T}\n\nConvert a symmetric matrix of 3x3 stress components to a 6-component vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DAxisymm},Array{T,2},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressvtot!","text":"stressvtot!(::Type{DeforModelRed2DAxisymm}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a 4-vector to a  matrix of 3x3 stress components (tensor).\n\nConvert a 4-vector to a symmetric matrix of 3x3 stress components (tensor).\n\nThe stress vector components need to be ordered as:     sigmax, sigmay, sigmaz, tauxy.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,2},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressvtot!","text":"stressvtot!(::Type{DeforModelRed2DStrain}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a vector to a  matrix of 2x2 stress components (symmetric tensor).\n\nIf v has 4 entries, also the t[3,3] matrix entry is set.\n\nThe stress vector components need to be ordered as:     sigmax, sigmay, tauxy, sigmaz, which is the ordering used for the plane-strain model reduction.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStress},Array{T,2},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressvtot!","text":"stressvtot!(::Type{DeforModelRed2DStress}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a 3-vector to a  matrix of 2x2 stress components (symmetric tensor).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,2},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressvtot!","text":"stressvtot!(::Type{DeforModelRed3D}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a 6-vector to a  matrix of 3x3 stress components (symmetric tensor).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4checksymmetry-Tuple{Any}","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4checksymmetry","text":"tens4checksymmetry(C4th)\n\nIf the fourth-order tensor of material elasticity has the full set of symmetries, return true; otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4deviator!-Union{Tuple{Array{T,4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4deviator!","text":"tens4deviator!(t::Array{T, 4}) where {T}\n\nCompute 4th-order deviator tensor.\n\nDouble contraction of a second order tensor with this fourth-order tensor produces the deviator part of the second order tensor.\n\nExample\n\nThe product of the deviator tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4deviator!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show tr((S - tr(S)/3*I) ), tr(tS)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4dot2!-Union{Tuple{T}, Tuple{Array{T,2},Array{T,4},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4dot2!","text":"tens4dot2!(R::Array{T, 2}, F::Array{T, 4}, S::Array{T, 2}) where {T}\n\nCompute the double contraction of a 4th-order and a 2nd-order tensors.\n\nnote: Note\n\n\nThe double contraction  of two second-order sensors is defined as  A:B = tr(A'*B) = A_ij B_ij\n\nThe resulting second-order tensor is first zeroed out, and then the result is accumulated.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4identity!-Union{Tuple{Array{T,4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4identity!","text":"tens4identity!(t::Array{T, 4}) where {T}\n\nCompute 4th-order identity tensor.\n\nExample\n\nThe product of the identity tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4identity!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show S - tS\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4ijkl!-Union{Tuple{FB}, Tuple{FA}, Tuple{T}, Tuple{Array{T,4},FA,FB}} where FB where FA where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4ijkl!","text":"tens4ijkl!(t::Array{T, 4}, A::FA, B::FB, op = :+) where {T, FA, FB}\n\nFill a 4th-order tensor as a dyadic product of two 2nd-order tensors.\n\nThe i,j,k,l component is given as t[i,j,k,l]=A(i,j)*B(k,l).\n\nnote: Note\n\n\nThe tensor is accumulated to. It needs to be initialized to zero, if that is desired as the initial state.\n\nExample\n\nt = fill(0.0, 3, 3, 3, 3)\ndelta = (I, J) -> I == J ? 1.0 : 0.0\ntens4ijkl!(t, delta, delta)\nS = rand(3, 3)\n@show tr(S) * I\ntS = fill(0.0, 3, 3)\n@show tens4dot2!(tS, t, S)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4ikjl!-Union{Tuple{FB}, Tuple{FA}, Tuple{T}, Tuple{Array{T,4},FA,FB}} where FB where FA where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4ikjl!","text":"tens4ikjl!(t::Array{T, 4}, A::FA, B::FB) where {T, FA, FB}\n\nFill a 4th-order tensor as a dyadic product of two 2nd-order tensors.\n\nThe i,j,k,l component is given as t[i,j,k,l]=A(i,k)*B(j,l).\n\nnote: Note\n\n\nThe tensor is accumulated to. It needs to be initialized to zero, if that is desired as the initial state.\n\nExample\n\nt = fill(0.0, 3, 3, 3, 3)\ndelta = (I, J) -> I == J ? 1.0 : 0.0\ntens4ikjl!(t, delta, delta)\nS = rand(3, 3)\n@show transpose(S) \ntS = fill(0.0, 3, 3)\n@show transpose(S) - tens4dot2!(tS, t, S)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4iljk!-Union{Tuple{FB}, Tuple{FA}, Tuple{T}, Tuple{Array{T,4},FA,FB}} where FB where FA where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4iljk!","text":"tens4iljk!(t::Array{T, 4}, A::FA, B::FB) where {T, FA, FB}\n\nFill a 4th-order tensor as a dyadic product of two 2nd-order tensors.\n\nThe i,j,k,l component is given as t[i,j,k,l]=A(i,l)*B(j,k).\n\nnote: Note\n\n\nThe tensor is accumulated to. It needs to be initialized to zero, if that is desired as the initial state.\n\nExample\n\nt = fill(0.0, 3, 3, 3, 3)\ndelta = (I, J) -> I == J ? 1.0 : 0.0\ntens4iljk!(t, delta, delta)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\n@show S - tens4dot2!(tS, t, S)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4skewor!-Union{Tuple{Array{T,4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4skewor!","text":"tens4skewor!(t::Array{T, 4}) where {T}\n\nCompute 4th-order skewor tensor.\n\nDouble contraction of a second order tensor with this fourth-order tensor produces the skew part of the second order tensor.\n\nExample\n\nThe product of the skewor tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4skewor!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show (S - S')/2 * I - tS\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4symmetrizor!-Union{Tuple{Array{T,4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4symmetrizor!","text":"tens4symmetrizor!(t::Array{T, 4}) where {T}\n\nCompute 4th-order symmetrizor tensor.\n\nDouble contraction of a second order tensor with this fourth-order tensor produces the symmetric part of the second order tensor.\n\nExample\n\nThe product of the symmetrizor tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4symmetrizor!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show (S + S')/2 * I - tS\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4symmt6x6tot!-Union{Tuple{T}, Tuple{Array{T,4},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4symmt6x6tot!","text":"tens4symmt6x6tot!(ST::Array{T, 4}, M::FMat{T}) where {T}\n\nConvert a symmetric 6 x 6 matrix to a symmetric 4th-order tensor.\n\n!!! Note The order corresponds to the arrangement of the components of stress (or strain) tensor, symmetric, three-dimensional, into a 6-component  vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4symmtto6x6t!-Union{Tuple{T}, Tuple{Array{T,2},Array{T,4}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4symmtto6x6t!","text":"tens4symmtto6x6t!(M::FMat{T}, ST::Array{T, 4}) where {T}\n\nConvert a symmetric 4th-order tensor to a 6 x 6 matrix.\n\n!!! Note The order corresponds to the arrangement of the components of stress (or strain) tensor, symmetric, three-dimensional, into a 6-component  vector.\n\nExample\n\nJ=tens4_ijkl(eye(3),eye(3))\nproduces the tracor:\nT=rand(3); \nsum(diag(T))*eye(3)\nt= tens4_dot_2(J,T)\nM= tens4_symm_to_6(ST)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4tracor!-Union{Tuple{Array{T,4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4tracor!","text":"tens4tracor!(t::Array{T, 4}) where {T}\n\nCompute 4th-order tracor tensor.\n\nDouble contraction of a second order tensor with this fourth-order tensor produces the spherical part of the second order tensor.\n\nExample\n\nThe product of the tracor tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4tracor!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show tr(S) * I - tS\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4transposor!-Union{Tuple{Array{T,4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4transposor!","text":"tens4transposor!(t::Array{T, 4}) where {T}\n\nCompute 4th-order transposor tensor.\n\nExample\n\nThe product of the transposor tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4transposor!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show S' - tS\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Material-models-for-elasticity","page":"Functions","title":"Material models for elasticity","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.MatDeforLinearElasticModule, FinEtoolsDeforLinear.MatDeforElastIsoModule, FinEtoolsDeforLinear.MatDeforElastOrthoModule,]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforLinearElasticModule.tangentmoduli!-Tuple{AbstractMatDeforLinearElastic,Array{Float64,2},Float64,Float64,Array{Float64,2},Int64}","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforLinearElasticModule.tangentmoduli!","text":"tangentmoduli!(self::AbstractMatDeforLinearElastic,  D::FFltMat,  t::FFlt, dt::FFlt, loc::FFltMat, label::FInt)\n\nCalculate the material stiffness matrix.\n\nD = matrix of tangent moduli, supplied as a buffer and overwritten. Returned\n\nas output.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforLinearElasticModule.thermalstrain!","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforLinearElasticModule.thermalstrain!","text":"thermalstrain!(self::AbstractMatDeforLinearElastic, thstrain::FFltVec, dT= 0.0)\n\nCompute thermal strain from the supplied temperature increment.\n\nthstrain = thermal strain vector, supplied as buffer, returned as output.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforLinearElasticModule.update!","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforLinearElasticModule.update!","text":"update!(self::AbstractMatDeforLinearElastic,  stress::FFltVec, output::FFltVec,  strain::FFltVec, thstrain::FFltVec=zeros(6), t::FFlt= 0.0, dt::FFlt= 0.0,  loc::FFltMat=zeros(3,1), label::FInt=0, quantity=:nothing)\n\nUpdate material state.\n\nstrain = strain vector,\nthstrain = thermal strain vector,\nt = current time,\ndt = current time step,\nloc = location of the quadrature point in global Cartesian coordinates,\nlabel = label of the finite element in which the quadrature point is found.\n\nOutput\n\nstress = stress vector, allocated by the caller with a size of the number of stress and\n\nstrain components, nstressstrain. The components of the stress vector are calculated and stored in the stress vector.\n\noutput =  array which is (if necessary) allocated  in an appropriate size, filled with the output quantity, and returned.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/FV32_tut.html#TEST-FV32:-Cantilevered-tapered-membrane,-free-vibration","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"","category":"section"},{"location":"tutorials/FV32_tut.html#Description","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"Description","text":"","category":"section"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"FV32: Cantilevered tapered membrane is a test recommended by the National Agency for Finite Element Methods and Standards (U.K.): Test FV32 from NAFEMS publication TNSB, Rev. 3, The Standard NAFEMS Benchmarks, October 1990.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"Reference solution: 44.623  130.03  162.70  246.05  379.90  391.44 for the first six modes.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"The benchmark is originally for plane stress conditions. We simulate the plane-stress conditions with a three-dimensional mesh that is constrained along one plane of nodes to effect the constrained motion only in the plane of the trapezoidal membrane.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"(Image: )","category":"page"},{"location":"tutorials/FV32_tut.html#References","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"References","text":"","category":"section"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"[1] Test FV32 from NAFEMS publication TNSB, Rev. 3, The Standard NAFEMS Benchmarks, October 1990.","category":"page"},{"location":"tutorials/FV32_tut.html#Goals","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"Goals","text":"","category":"section"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"Show how to generate hexahedral mesh in a rectangular block  and shape it into a trapezoid.\nSet up model data for the solution algorithms.\nUse two different finite element model machines to evaluate the stiffness and the mass.\nExecute the modal algorithm and export the results with another algorithm.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"#","category":"page"},{"location":"tutorials/FV32_tut.html#Definitions","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"Definitions","text":"","category":"section"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"Bring in the required support from the basic linear algebra, eigenvalue solvers, and the finite element tools.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"using LinearAlgebra\nusing Arpack\nusing FinEtools\nusing FinEtools\nusing FinEtoolsDeforLinear\nusing FinEtoolsDeforLinear: AlgoDeforLinearModule","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"The input data is given by the benchmark.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"E = 200*phun(\"GPA\");\nnu = 0.3;\nrho= 8000*phun(\"KG/M^3\");\nL = 10*phun(\"M\");\nW0 = 5*phun(\"M\");\nWL = 1*phun(\"M\");\nH = 0.05*phun(\"M\");","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"We shall generate a three-dimensional mesh. It should have 1 element through the thickness, and 8 and 4 elements in the plane of the membrane.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"nL, nW, nH = 8, 4, 1;# How many element edges per side?","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"The reference frequencies are obtained from [1].","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"Reffs = [44.623 130.03  162.70  246.05  379.90  391.44]","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"The three-dimensional mesh of 20 node serendipity hexahedral should correspond to the plane-stress quadratic serendipity quadrilateral (CPS8R) used in the Abaqus benchmark. We simulate the plane-stress conditions with a three-dimensional mesh that is constrained along one plane of nodes to effect the constrained motion only in the plane of the trapezoidal membrane. No bending out of plane! First we generate mesh of a rectangular block.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"fens,fes = H20block(1.0, 2.0, 1.0, nL, nW, nH)","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"Now distort the rectangular block into the tapered plate.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"for i in 1:count(fens)\n    xi, eta, theta = fens.xyz[i,:];\n    eta = eta - 1.0\n    fens.xyz[i,:] = [xi*L eta*(1.0 - 0.8*xi)*W0/2 theta*H/2];\nend","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"We can visualize the mesh with Paraview (for instance).","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"File =  \"FV32-mesh.vtk\"\nvtkexportmesh(File, fens, fes)\n@async run(`\"paraview.exe\" $File`)","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"The simulation will be executed with the help of algorithms defined in the package FinEtoolsDeforLinear. The algorithms accept a dictionary of model data. The model data dictionary will be built up as follows.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"First we make the interior region. The model reduction is for a three-dimensional finite element model.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"MR = DeforModelRed3D\nmaterial = MatDeforElastIso(MR, rho, E, nu, 0.0)","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"We shall create two separate finite element model machines. They are distinguished by the quadrature rule. The mass rule, in order to evaluate the mass matrix accurately, needs to be of higher order than the one we prefer to use for the stiffness.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"region1 = FDataDict(\"femm\"=>FEMMDeforLinear(MR, IntegDomain(fes, GaussRule(3,2)), material), \"femm_mass\"=>FEMMDeforLinear(MR, IntegDomain(fes, GaussRule(3,3)), material))","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"Select nodes that will be clamped.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"nl1 = selectnode(fens; plane=[1.0 0.0 0.0 0.0], thickness=H/1.0e4)\nebc1 = FDataDict(\"node_list\"=>nl1, \"component\"=>1, \"displacement\"=>0.0)\nebc2 = FDataDict(\"node_list\"=>nl1, \"component\"=>2, \"displacement\"=>0.0)\nebc3 = FDataDict(\"node_list\"=>nl1, \"component\"=>3, \"displacement\"=>0.0)","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"Export  a VTK file to visualize the selected points. Choose the representation \"Points\", and select color and size approximately 4. These notes should correspond to the clamped base of the membrane.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"File =  \"FV32-nl1.vtk\"\nvtkexportmesh(File, fens, FESetP1(reshape(nl1, length(nl1), 1)))","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"Select all nodes on the plane Z = 0. This will be prevented from moving in the Z direction.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"nl4 = selectnode(fens; plane=[0.0 0.0 1.0 0.0], thickness=H/1.0e4)\nebc4 = FDataDict(\"node_list\"=>nl4, \"component\"=>3, \"displacement\"=>0.0)","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"Export  a VTK file to visualize the selected points. Choose the representation \"Points\", and select color and size approximately 4. These points all should be on the bottom face of the three-dimensional domain.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"File =  \"FV32-nl4.vtk\"\nvtkexportmesh(File, fens, FESetP1(reshape(nl4, length(nl4), 1)))","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"Make model data: the nodes, the regions, the boundary conditions, and the number of eigenvalues are set. Note that the number of eigenvalues needs to be set to 6+N,  where 6 is the number of rigid body modes, and N is the number of deformation frequencies we are interested in.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"neigvs = 10                  # how many eigenvalues\nmodeldata =  FDataDict(\"fens\"=> fens, \"regions\"=>  [region1], \"essential_bcs\"=>[ebc1 ebc2 ebc3 ebc4], \"neigvs\"=>neigvs)","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"Solve using an algorithm: the modal solver. The solver will supplement the model data with the geometry and displacement fields, and the solution (eigenvalues, eigenvectors), and the data upon return can be extracted from the dictionary.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"modeldata = AlgoDeforLinearModule.modal(modeldata)","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"Here we extract the angular velocities corresponding to the natural frequencies.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"fs = modeldata[\"omega\"]/(2*pi)\nprintln(\"Eigenvalues: $fs [Hz]\")\nprintln(\"Percentage frequency errors: $((vec(fs[1:6]) - vec(Reffs))./vec(Reffs)*100)\")","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"The problem was solved for instance with Abaqus, using plane stress eight node elements. The results were:","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"Element Frequencies (relative errors)\nCPS8R 44.629 (0.02)   130.11 (0.06)   162.70 (0.00)   246.42 (0.15)   381.32 (0.37)   391.51 (0.02)","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"Compared these numbers with those computed by our three-dimensional model.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"The mode shapes may be visualized with paraview. Here is for instance mode 8: (Image: )","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"The algorithm to export the mode shapes expects some input. We shall specify the filename and the numbers of modes to export.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"modeldata[\"postprocessing\"] = FDataDict(\"file\"=>\"FV32-modes\", \"mode\"=>1:neigvs)\nmodeldata = AlgoDeforLinearModule.exportmode(modeldata)","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"The algorithm attaches a little bit to the name of the exported file. If paraview.exe is installed, the command below should bring up the postprocessing file.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"@async run(`\"paraview.exe\" $(modeldata[\"postprocessing\"][\"file\"]*\"1.vtk\")`)","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"To animate the mode shape in Paraview do the following:","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"Apply the filter \"Warp by vector\".\nTurn on the \"Animation view\".\nAdd the mode shape data set (\"WarpByVector1\") by clicking the \"+\".\nDouble-click the line with the data set. The \"Animation Keyframes\" dialog will come up. Double-click \"Ramp\" interpolation, and change it to \"Sinusoid\". Set the frequency to 1.0. Change the \"Value\" from 0 to 100.\nIn the animation view, set the mode to \"Real-time\", and the duration to 4.0 seconds.\nClick on the \"Play\" button. If you wish, click on the \"Loop\" button.","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"true","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"","category":"page"},{"location":"tutorials/FV32_tut.html","page":"TEST FV32: Cantilevered tapered membrane, free vibration","title":"TEST FV32: Cantilevered tapered membrane, free vibration","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html#Vibration-of-a-cube-of-nearly-incompressible-material","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"","category":"section"},{"location":"tutorials/unit_cube_modes_tut.html#Description","page":"Vibration of a cube of nearly incompressible material","title":"Description","text":"","category":"section"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"Compute the free-vibration spectrum of a unit cube of nearly incompressible isotropic material, E = 1,  = 0.499, and  = 1 (refer to [1]).","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"The solution with the FinEtools package is compared with a commercial software  solution, and hence we also export the model to Abaqus.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html#References","page":"Vibration of a cube of nearly incompressible material","title":"References","text":"","category":"section"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"[1] Puso MA, Solberg J (2006) A stabilized nodally integrated tetrahedral. International Journal for Numerical Methods in Engineering 67: 841-867. [2] P. Krysl, Mean-strain 8-node hexahedron with optimized energy-sampling stabilization, Finite Elements in Analysis and Design 108 (2016) 4153.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"(Image: )","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html#Goals","page":"Vibration of a cube of nearly incompressible material","title":"Goals","text":"","category":"section"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"Show how to generate hexahedral mesh, mirroring and merging together parts.\nExport the model to Abaqus.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"#","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html#Definitions","page":"Vibration of a cube of nearly incompressible material","title":"Definitions","text":"","category":"section"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"This is the finite element toolkit itself.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"using FinEtools","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"The linear stress analysis application is implemented in this package.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"using FinEtoolsDeforLinear","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"Convenience import.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"using FinEtools.MeshExportModule","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"The eigenvalue problem is solved with the Lanczos algorithm from this package.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"using Arpack","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"The material properties and dimensions are defined with physical units.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"E = 1*phun(\"PA\");\nnu = 0.499;\nrho = 1*phun(\"KG/M^3\");\na = 1*phun(\"M\"); # length of the side of the cube","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"We generate a mesh of  5 x 5 x 5 serendipity 20-node hexahedral elements in a regular grid.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"fens, fes  = H20block(a, a, a, 5, 5, 5);","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"The problem is solved in three dimensions and hence we create the displacement field as three-dimensional with three displacement components per node. The degrees of freedom are then numbered  (note that no essential boundary conditions are applied, since the cube is free-floating).","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"geom = NodalField(fens.xyz)\nu = NodalField(zeros(size(fens.xyz,1),3)) # displacement field\nnumberdofs!(u);","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"The model is fully three-dimensional, and hence the material model  and the FEMM created below need to refer to an appropriate model-reduction scheme.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"MR = DeforModelRed3D\nmaterial = MatDeforElastIso(MR, rho, E, nu, 0.0);","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"Note that we compute the stiffness  and the mass matrix using different FEMMs. The difference  is only the quadrature rule chosen: in order to make the mass matrix  non-singular, an accurate  Gauss rule  needs to be used, whereas for the stiffness matrix we want to avoid the excessive stiffness  and therefore the reduced Gauss rule is used.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"femm = FEMMDeforLinear(MR, IntegDomain(fes, GaussRule(3,2)), material);\nK = stiffness(femm, geom, u)\nfemm = FEMMDeforLinear(MR, IntegDomain(fes, GaussRule(3,3)), material)\nM = mass(femm, geom, u);","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"The free vibration problem  can now be solved.   In order for the eigenvalue solver  to work well, we apply mass-shifting (otherwise the first matrix given to the solver  stiffness  would be singular). We specify the number of eigenvalues to solve for, and we  guess the frequency  with which to shift as 0.01 Hz.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"neigvs = 20 # how many eigenvalues\nOmegaShift = (0.01*2*pi)^2; # The frequency with which to shift","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"The eigs routine can now be invoked to solve for a given number of frequencies from the smallest-magnitude end of the spectrum. Note that the mass shifting  needs to be undone when the solution is obtained.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"evals, evecs, nconv = eigs(K+OmegaShift*M, M; nev=neigvs, which=:SM)\n@show nconv == neigvs\nevals = evals .- OmegaShift;\nfs = real(sqrt.(complex(evals)))/(2*pi)\nprintln(\"Eigenvalues: $fs [Hz]\")","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"The first nonzero frequency, frequency 7, should be around .263 Hz.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"The computed mode can be visualized in Paraview. Use the  \"Animation view\" to produce moving pictures for the mode.","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"mode = 7\nscattersysvec!(u, v[:,mode])\nFile =  \"unit_cube_modes.vtk\"\nvtkexportmesh(File, fens, fes; vectors=[(\"mode$mode\", u.values)])\n@async run(`\"paraview.exe\" $File`);","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"Finally  we export the model to Abaqus.  Note that we specify the mass density property (necessary for dynamics).","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"AE = AbaqusExporter(\"unit_cube_modes_h20\");\nHEADING(AE, \"Vibration modes of unit cube  of almost incompressible material.\");\nCOMMENT(AE, \"The  first six frequencies are rigid body modes.\");\nCOMMENT(AE, \"The  first nonzero frequency (7) should be around 0.26 Hz\");\nPART(AE, \"part1\");\nEND_PART(AE);\nASSEMBLY(AE, \"ASSEM1\");\nINSTANCE(AE, \"INSTNC1\", \"PART1\");\nNODE(AE, fens.xyz);\nCOMMENT(AE, \"The hybrid form of the serendipity hexahedron is chosen because\");\nCOMMENT(AE, \"the material is  nearly incompressible.\");\nELEMENT(AE, \"C3D20RH\", \"AllElements\", 1, connasarray(fes))\nORIENTATION(AE, \"GlobalOrientation\", vec([1. 0 0]), vec([0 1. 0]));\nSOLID_SECTION(AE, \"elasticity\", \"GlobalOrientation\", \"AllElements\");\nEND_INSTANCE(AE);\nEND_ASSEMBLY(AE);\nMATERIAL(AE, \"elasticity\")\nELASTIC(AE, E, nu)\nDENSITY(AE, rho)\nSTEP_FREQUENCY(AE, neigvs)\nEND_STEP(AE)\nclose(AE)","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"It remains is to load the model into Abaqus and execute it as a job. Alternatively Abaqus can be called on the input file to carry out the analysis at the command line as","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"abaqus job=unit_cube_modes_h20.inp","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"The output database unit_cube_modes_h20.odb can then be loaded for postprocessing, for instance from the command line as","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"abaqus viewer database=unit_cube_modes_h20.odb","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"Don't forget to compare the computed frequencies and the mode shapes.  For instance, the first six frequencies should be nearly 0, and the seventh frequency should be approximately  0.262 Hz. There may be  very minor differences due to the fact that  the FinEtools formulation is purely displacement-based, whereas the Abaqus model is hybrid (displacement plus pressure).","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"","category":"page"},{"location":"tutorials/unit_cube_modes_tut.html","page":"Vibration of a cube of nearly incompressible material","title":"Vibration of a cube of nearly incompressible material","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"R0031/3 Composite plate test","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"This is a test recommended by the National Agency for Finite Element Methods and Standards (U.K.): Test R0031/3 from NAFEMS publication R0031, Composites Benchmarks, February 1995. It is  a composite  (sandwich) plate of square shape, simply supported along all four edges. Uniform transverse loading is applied to the top skin. The modeled part is one quarter of the full plate here. The serendipity  quadratic hexahedra  are used, with full integration.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"The solution  can be compared with the benchmark results  in the Abaqus manual \"Abaqus Benchmarks Guide\".","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"We begin  by using the toolkit FinEtools.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"using FinEtools","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"Further, we use the linear-deformation application package.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"using FinEtoolsDeforLinear","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"The problem will be solved with a pre-packaged algorithm.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"using FinEtoolsDeforLinear.AlgoDeforLinearModule","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"For plotting we use the following packages.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"using UnicodePlots\nimport Statistics: mean","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"The material parameters are specified for an orthotropic material model.  The units are attached using the phun function which can take the specification of the units and spits out the numerical multiplier. Here the benchmark specifies the input parameters in the English Imperial units. The skin  material:","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"E1s = 1.0e7*phun(\"psi\")\nE2s = 0.4e7*phun(\"psi\")\nE3s = 0.4e7*phun(\"psi\")\nnu12s = 0.3\nnu13s = 0.3\nnu23s = 0.3\nG12s = 0.1875e7*phun(\"psi\")\nG13s = 0.1875e7*phun(\"psi\")\nG23s = 0.1875e7*phun(\"psi\");","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"The core material:","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"E1c = 10.0*phun(\"psi\")\nE2c = 10.0*phun(\"psi\")\nE3c = 10e4.*phun(\"psi\")\nnu12c = 0.\nnu13c = 0.\nnu23c = 0.\nG12c = 10.0*phun(\"psi\")\nG13c = 3.0e4*phun(\"psi\")\nG23c = 1.2e4*phun(\"psi\");","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"The magnitude  of the distributed uniform transfers loading is","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"tmag = 100*phun(\"psi\");","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"Now we generate the mesh.   The sandwich plate volume is divided  into a regular Cartesian grid in the X and Y direction in the plane of the plate, and  in the thickness direction  it is divided  into three layers, with each layer again subdivided into multiple  elements.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"L = 10.0*phun(\"in\") # side of the square plate\nnL = 8 # number of elements along the side of the plate\nxs = collect(linearspace(0.0, L/2, nL+1))\nys = collect(linearspace(0.0, L/2, nL+1));;","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"The thicknesses are specified from the bottom of the plate: skin, core, and then again skin.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"ts = [0.028; 0.75; 0.028]*phun(\"in\")\nnts = [2; 3;  2]; # number of elements through the thickness for each layer","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"The H8layeredplatex meshing function generates the mesh and marks the elements  with a label identifying  the layer to which they belong.  We will use the label to create separate regions, with their own separate materials.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"fens,fes = H8layeredplatex(xs, ys, ts, nts)","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"The linear hexahedra are subsequently converted to serendipity (quadratic) elements.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"fens,fes = H8toH20(fens,fes);","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"The model reduction  here simply says this is a fully three-dimensional model.  The two orthotropic materials are created.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"MR = DeforModelRed3D\nskinmaterial = MatDeforElastOrtho(MR,\n  0.0, E1s, E2s, E3s,\n  nu12s, nu13s, nu23s,\n  G12s, G13s, G23s,\n  0.0, 0.0, 0.0)\ncorematerial = MatDeforElastOrtho(MR,\n  0.0, E1c, E2c, E3c,\n  nu12c, nu13c, nu23c,\n  G12c, G13c, G23c,\n  0.0, 0.0, 0.0);","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"Now we are ready to create three material regions:  one for the bottom skin, one for the core, and one for the top skin. The selection of the finite elements assigned to each of the three regions is based on the label. Full Gauss quadrature  is used.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"rl1 = selectelem(fens, fes, label=1)\nskinbot = FDataDict(\"femm\"=>FEMMDeforLinear(MR,\n    IntegDomain(subset(fes, rl1), GaussRule(3, 3)), skinmaterial))\n\nrl3 = selectelem(fens, fes, label=3)\nskintop = FDataDict(\"femm\"=>FEMMDeforLinear(MR,\n    IntegDomain(subset(fes, rl3), GaussRule(3, 3)), skinmaterial))\n\nrl2 = selectelem(fens, fes, label=2)\ncore = FDataDict(\"femm\"=>FEMMDeforLinear(MR,\n    IntegDomain(subset(fes, rl2), GaussRule(3, 3)), corematerial));","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"Note that since we did not specify the material coordinate system,  the default is assumed  (which is identical to the global Cartesian coordinate system).","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"@show skinbot[\"femm\"].mcsys","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"Next we select the nodes to which  essential boundary conditions  will be applied.  A node is selected  if it is within the specified box  which for the purpose of the test  is inflated in all directions by tolerance. The  nodes on the planes of symmetry need to be selected, and also  the nodes  along the edges (faces) to be simply supported  need to be identified.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"tolerance = 0.0001*phun(\"in\")\nlx0 = selectnode(fens, box=[0.0 0.0 -Inf Inf -Inf Inf], inflate=tolerance)\nlxL2 = selectnode(fens, box=[L/2 L/2 -Inf Inf -Inf Inf], inflate=tolerance)\nly0 = selectnode(fens, box=[-Inf Inf 0.0 0.0 -Inf Inf], inflate=tolerance)\nlyL2 = selectnode(fens, box=[-Inf Inf L/2 L/2 -Inf Inf], inflate=tolerance);","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"We have four sides  of the quarter of the plate, two on each plane of symmetry, and two  along the circumference. Hence we create  four essential boundary condition definitions, one for each of the sides of the plate.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"ex0 = FDataDict( \"displacement\"=>  0.0, \"component\"=> 3, \"node_list\"=>lx0 )\nexL2 = FDataDict( \"displacement\"=>  0.0, \"component\"=> 1, \"node_list\"=>lxL2 )\ney0 = FDataDict( \"displacement\"=>  0.0, \"component\"=> 3, \"node_list\"=>ly0 )\neyL2 = FDataDict( \"displacement\"=>  0.0, \"component\"=> 2, \"node_list\"=>lyL2 );","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"The traction on the top surface of the top skin is applied to the subset  of the surface mesh of the entire domain. First we compute the  boundary mesh, and then from the boundary mesh we select the surface finite elements that  \"face\" upward (along the positive Z axis).","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"bfes = meshboundary(fes)\nttopl = selectelem(fens, bfes; facing=true, direction = [0.0 0.0 1.0])\nTrac = FDataDict(\"traction_vector\"=>[0.0; 0.0; -tmag],\n    \"femm\"=>FEMMBase(IntegDomain(subset(bfes, ttopl), GaussRule(2, 3))));","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"The model data  is composed of the  finite element nodes, an array  of the regions, an array of the essential boundary condition definitions, and  an array of  the traction (natural) boundary condition definitions.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"modeldata = FDataDict(\"fens\"=>fens,\n \"regions\"=>[skinbot, core, skintop], \"essential_bcs\"=>[ex0, exL2, ey0, eyL2],\n \"traction_bcs\"=> [Trac]\n );","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"With the model data assembled,  we can now call the algorithm.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"modeldata = AlgoDeforLinearModule.linearstatics(modeldata);","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"The  computed solution can now be postprocessed. The displacement is reported at the center of the plate, along the line in the direction of the loading. We select all the nodes along this line.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"u = modeldata[\"u\"]\ngeom = modeldata[\"geom\"]\nlcenter = selectnode(fens, box=[L/2 L/2  L/2 L/2 -Inf Inf], inflate=tolerance);","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"The variation of the displacement along this line  can be plotted  as (the bottom surface of the shell is at Z=0):","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"ix = sortperm(geom.values[lcenter, 3])","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"Plot the data","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"a = lineplot(geom.values[lcenter, 3][ix], u.values[lcenter, 3][ix]./phun(\"in\"), name = \"cold leg\", xlabel = \"Z coordinate [in]\", ylabel = \"Vert displ [in]\", canvas = DotCanvas)\ndisplay(a)","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"A reasonable single number to report for the deflection at the center is the average of the displacements at the nodes at the center of the plate (-0.136348):","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"cdis = mean(u.values[lcenter, 3])/phun(\"in\");\nprintln(\"Center node displacements $(cdis) [in]; NAFEMS-R0031-3 reference: 0.123 [in]\")","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"The reference displacement at the center of -0.123 [in] reported for the benchmark is evaluated from  an analytical formulation that neglects transverse  (pinching) deformation. Due to the soft core, significant pinching is observed. The solution to the benchmark  obtained in Abaqus  with incompatible hexahedral elements (with the same number of elements as in the stacked continuum shell solution) is -0.131 [in], which is close to our own solution. Hence, our own solution is probably more accurate than the reference solution because it includes an effect neglected in the benchmark solution.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"The deformed shape can be investigated  visually in paraview (uncomment the line at the bottom if you have paraview in your  PATH):","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"File =  \"NAFEMS-R0031-3-plate.vtk\"\nvtkexportmesh(File, connasarray(fes), geom.values, FinEtools.MeshExportModule.H20;\n    scalars = [(\"Layer\", fes.label)], vectors = [(\"displacement\", u.values)])","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"@async run(\"paraview.exe\" $File);","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"Note that the  VTK file will contain element labels (which can help us distinguish between the layers) as scalar field, and the displacements as a vector field.","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"","category":"page"},{"location":"tutorials/R0031-3-Composite-benchmark_tut.html","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/tutorials.html","page":"Tutorials","title":"Tutorials","text":"Table of contents","category":"page"},{"location":"tutorials/tutorials.html#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/tutorials.html","page":"Tutorials","title":"Tutorials","text":"Cook membrane, plane stress\nComposite benchmark R0031-3\nTwisted beam, export to Abaqus\nNearly incompressible cube vibration\nNearly incompressible cube vibration, alternative models\n13H benchmark, forced vibration\nFV32 benchmark, free vibration of trapezoidal membrane","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html#Vibration-of-a-cube-of-nearly-incompressible-material:-alternative-models","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"","category":"section"},{"location":"tutorials/unit_cube_modes_alt_tut.html#Description","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Description","text":"","category":"section"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"Compute the free-vibration spectrum of a unit cube of nearly incompressible isotropic material, E = 1,  = 0.499, and  = 1 (refer to [1]).","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"The solution with the serendipity quadratic hexahedron is supplemented with solutions obtained with advanced finite elements: nodal-integration energy stabilized hexahedra and tetrahedra, and mean-strain hexahedra and tetrahedra.","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html#References","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"References","text":"","category":"section"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"[1] Puso MA, Solberg J (2006) A stabilized nodally integrated tetrahedral. International Journal for Numerical Methods in Engineering 67: 841-867. [2] P. Krysl, Mean-strain 8-node hexahedron with optimized energy-sampling stabilization, Finite Elements in Analysis and Design 108 (2016) 4153.","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"(Image: )","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html#Goals","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Goals","text":"","category":"section"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"Set up a simulation loop that will run all the models and collect data.\nPresent the computed spectrum curves.","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"#","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html#Definitions","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Definitions","text":"","category":"section"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"This is the finite element toolkit itself.","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"using FinEtools","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"The linear stress analysis application is implemented in this package.","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"using FinEtoolsDeforLinear","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"Convenience import.","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"using FinEtools.MeshExportModule","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"The eigenvalue problem is solved with the Lanczos algorithm from this package.","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"using Arpack\n\nusing SymRCM","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"The material properties and dimensions are defined with physical units.","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"E = 1*phun(\"PA\");\nnu = 0.499;\nrho = 1*phun(\"KG/M^3\");\na = 1*phun(\"M\"); # length of the side of the cube\nN = 8\nneigvs = 20 # how many eigenvalues\nOmegaShift = (0.01*2*pi)^2; # The frequency with which to shift","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"The model is fully three-dimensional, and hence the material model  and the FEMM created below need to refer to an appropriate model-reduction scheme.","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"MR = DeforModelRed3D\nmaterial = MatDeforElastIso(MR, rho, E, nu, 0.0);","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"models = [\n    (\"H20\", H20block, GaussRule(3,2), FEMMDeforLinear, 1),\n    (\"ESNICEH8\", H8block, NodalTensorProductRule(3), FEMMDeforLinearESNICEH8, 2),\n    (\"ESNICET4\", T4block, NodalSimplexRule(3), FEMMDeforLinearESNICET4, 2),\n    (\"MSH8\", H8block, NodalTensorProductRule(3), FEMMDeforLinearMSH8, 2),\n    (\"MST10\", T10block, TetRule(4), FEMMDeforLinearMST10, 1),\n]","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"Run  the simulation loop over all the models.","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"results = let\n    results = []\n    for m in models\n        fens, fes  = m[2](a, a, a, m[5]*N, m[5]*N, m[5]*N);\n        @show count(fens)\n        geom = NodalField(fens.xyz)\n        u = NodalField(zeros(size(fens.xyz,1),3))\n        numbering = let\n            C = connectionmatrix(FEMMBase(IntegDomain(fes, m[3])), count(fens))\n            numbering = symrcm(C)\n        end\n        numberdofs!(u, numbering);\n        println(\"nfreedofs = $(u.nfreedofs)\")\n\n        femm = m[4](MR, IntegDomain(fes, m[3]), material);\n        femm = associategeometry!(femm, geom)\n        K = stiffness(femm, geom, u)\n        M = mass(femm, geom, u);\n\n        evals, evecs, nconv = eigs(K+OmegaShift*M, M; nev=neigvs, which=:SM)\n        @show nconv == neigvs\n        evals = evals .- OmegaShift;\n        fs = real(sqrt.(complex(evals)))/(2*pi)\n        println(\"$(m[1]) eigenvalues: $fs [Hz]\")\n        push!(results, (m, fs))\n    end\n    results # return it\nend\n\n\nusing PlotlyJS","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"Make sure we can edit the chart if we needed to.","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"options = Dict(\n        :showSendToCloud=>true,\n        :plotlyServerURL=>\"https://chart-studio.plotly.com\"\n        )","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"Create the layout.","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"layout = Layout(;width=650, height=500, xaxis=attr(title=\"Mode number [ND]\", type = \"linear\"), yaxis=attr(title=\"Frequency [Hz]\", type = \"linear\"), title = \"Natural frequencies\")","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"Create the graphs:","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"plots = [scatter(;x=vec(1:length(r[2])), y=vec(r[2]), mode=\"markers\", name = r[1][1]) for r in results]","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"Plot the graphs:","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"pl = plot(plots, layout; options)\ndisplay(pl)","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"","category":"page"},{"location":"tutorials/unit_cube_modes_alt_tut.html","page":"Vibration of a cube of nearly incompressible material: alternative models","title":"Vibration of a cube of nearly incompressible material: alternative models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html#Cook-panel-under-plane-stress","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"","category":"section"},{"location":"tutorials/Cook-plane-stress_tut.html#Description","page":"Cook panel under plane stress","title":"Description","text":"","category":"section"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"In this example we investigate the well-known benchmark of a tapered panel under plane stress conditions known under the name of Cook.  The problem has been solved many times with a variety of finite element models  and hence the solution is well-known.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html#Goals","page":"Cook panel under plane stress","title":"Goals","text":"","category":"section"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"Show how to generate the mesh.\nExecute the simulation with a static-equilibrium algorithm (solver).","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"#","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html#Definitions","page":"Cook panel under plane stress","title":"Definitions","text":"","category":"section"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"The problem is solved in a script.  We begin  by using the top-level module FinEtools. Further, we use the linear-deformation application package.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"using FinEtools\nusing FinEtoolsDeforLinear","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"With the algorithm modules, the problem can be set up (the materials, boundary conditions, and mesh are defined) and handed off to an algorithm (in this case linear static solution).  Then for postprocessing another set of algorithms can be invoked.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"using FinEtoolsDeforLinear.AlgoDeforLinearModule","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"A few  input parameters are defined: the material parameters. Note: the units are consistent, but unnamed.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"E = 1.0;\nnu = 1.0/3;","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"The geometry of the tapered panel.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"width = 48.0; height = 44.0; thickness  = 1.0;\nfree_height  = 16.0;","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"Location of tracked  deflection is the midpoint of the loaded edge.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"Mid_edge  = [48.0, 52.0];","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"The tapered panel is loaded along the free edge with a unit force, which is here converted to loading per unit area.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"magn = 1.0/free_height/thickness;# Magnitude of applied load","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"For the above input parameters the converged displacement of the tip  of the tapered panel in the direction of the applied shear load is","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"convutip = 23.97;","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"The mesh is generated as a rectangular block to begin with, and then the coordinates of the nodes are tweaked into the tapered panel shape. In this case we are using quadratic triangles (T6).","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"n = 10; # number of elements per side\nfens, fes = T6block(width, height, n, n)","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"Reshape the rectangle into a trapezoidal panel:","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"for i in 1:count(fens)\n    fens.xyz[i,2] += (fens.xyz[i,1]/width)*(height -fens.xyz[i,2]/height*(height-free_height));\nend","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"The  boundary conditions  are applied to selected finite element nodes.   The selection is based on the inclusion in a selection \"box\".","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"tolerance = minimum([width, height])/n/1000.;#Geometrical tolerance","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"Clamped edge of the membrane","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"l1 = selectnode(fens; box=[0.,0.,-Inf, Inf], inflate = tolerance);","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"The list of the selected nodes is then used twice,  to fix the degree of freedom  in the direction 1 and  in the direction 2. The essential-boundary condition data is stored in  dictionaries: ess1 and ess2.  These dictionaries  are used below to compose the computational model.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"ess1 = FDataDict(\"displacement\"=>  0.0, \"component\"=> 1, \"node_list\"=>l1);\ness2 = FDataDict(\"displacement\"=>  0.0, \"component\"=> 2, \"node_list\"=>l1);","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"The traction boundary condition is applied to the finite elements on the boundary of the panel. First we generate the three-node \"curve\" elements on the entire boundary of the panel.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"boundaryfes =  meshboundary(fes);","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"Then from these finite elements we choose the ones that are inside the box that captures the edge of the geometry to which the traction should be applied.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"Toplist  = selectelem(fens, boundaryfes, box= [width, width, -Inf, Inf ], inflate=  tolerance);","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"To apply the traction we create a finite element model machine (FEMM). For the evaluation of the traction it is sufficient to create a  \"base\" FEMM.  It consists of the geometry data IntegDomain (connectivity,  integration rule, evaluation  of the basis functions  and basis function gradients with respect to the parametric coordinates). This object is composed of the list of the finite elements and  an appropriate quadrature rule (Gauss rule here).","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"el1femm = FEMMBase(IntegDomain(subset(boundaryfes, Toplist), GaussRule(1, 3), thickness));","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"The traction boundary condition is specified with a constant traction vector and the FEMM that will be used to evaluate  the load vector.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"flux1 = FDataDict(\"traction_vector\"=>[0.0,+magn],\n    \"femm\"=>el1femm\n    );","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"We make the dictionary for the region (the interior of the domain).  The FEMM for the evaluation of the integrals over the interior of the domain (that is the stiffness matrix) and the material are needed. The geometry data  now is equipped with the  triangular  three-point rule. Note the model-reduction type which is used to dispatch to appropriate specializations of the material routines and the FEMM which needs to execute different code for different reduced-dimension models. Here the model reduction is \"plane stress\".","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"MR = DeforModelRed2DStress\nmaterial = MatDeforElastIso(MR,  0.0, E, nu, 0.0)\nregion1 = FDataDict(\"femm\"=>FEMMDeforLinear(MR, IntegDomain(fes, TriRule(3), thickness), material));","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"The model data is a dictionary.   In the present example it consists of the node set, the array of dictionaries for the regions, and arrays of dictionaries for each essential and natural boundary condition.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"modeldata = FDataDict(\"fens\"=>fens,\n \"regions\"=>[region1],\n \"essential_bcs\"=>[ess1, ess2],\n \"traction_bcs\"=>[flux1]\n );","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"When the model data is defined, we simply pass it to the algorithm.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"modeldata = AlgoDeforLinearModule.linearstatics(modeldata);","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"The model data is augmented in the algorithm by the nodal field representing the geometry and the displacement field  computed by solving the system of linear algebraic equations of equilibrium.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"u = modeldata[\"u\"];\ngeom = modeldata[\"geom\"];","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"The complete information returned from the algorithm  is","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"@show keys(modeldata)","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"Now we can extract the displacement at the mid-edge node and compare to the converged (reference) value. The code below selects the node inside a very small box of the size tolerance which presumably contains only a single node, the one at the midpoint of the edge.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"nl = selectnode(fens, box=[Mid_edge[1],Mid_edge[1],Mid_edge[2],Mid_edge[2]],\n          inflate=tolerance);\ntheutip = u.values[nl,:]\nprintln(\"displacement =$(theutip[2]) as compared to converged $convutip\")","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"For postprocessing  we will export a VTK file  with the displacement field (vectors)  and  one scalar field (sigma_xy).","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"modeldata[\"postprocessing\"] = FDataDict(\"file\"=>\"cookstress\",\n   \"quantity\"=>:Cauchy, \"component\"=>:xy);\nmodeldata = AlgoDeforLinearModule.exportstress(modeldata);","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"The  attribute \"postprocessing\" holds additional data computed and returned by the algorithm:","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"@show keys(modeldata[\"postprocessing\"])","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"The exported data can be digested as follows: modeldata[\"postprocessing\"] [\"exported\"] is an array of exported items.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"display(keys(modeldata[\"postprocessing\"][\"exported\"]))","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"Each entry of the array is a dictionary:","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"display(keys(modeldata[\"postprocessing\"][\"exported\"][1]))","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"Provided we have  paraview in the PATH, we can bring it up  to display the exported data.","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"File = modeldata[\"postprocessing\"][\"exported\"][1][\"file\"]\n@async run(`\"paraview.exe\" $File`);","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"We can also extract the minimum and maximum value of the shear stress (-0.06, and 0.12).","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"display(modeldata[\"postprocessing\"][\"exported\"][1][\"quantity\"])\ndisplay(modeldata[\"postprocessing\"][\"exported\"][1][\"component\"])\nfld = modeldata[\"postprocessing\"][\"exported\"][1][\"field\"]\nprintln(\"$(minimum(fld.values)) $(maximum(fld.values))\")\n\ntrue","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"","category":"page"},{"location":"tutorials/Cook-plane-stress_tut.html","page":"Cook panel under plane stress","title":"Cook panel under plane stress","text":"This page was generated using Literate.jl.","category":"page"},{"location":"guide/guide.html#Guide","page":"How to guide","title":"Guide","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The FinEtools package is used here to solve linear stress analysis (deformation) problems.","category":"page"},{"location":"guide/guide.html#Modules","page":"How to guide","title":"Modules","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The package FinEtoolsDeforLinear has the following structure:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"FinEtoolsDeforLinear is the  top-level module.\nLinear deformation:  AlgoDeforLinearModule (algorithms), DeforModelRedModule (model-reduction definitions, 3D, plane strain and stress, and so on), FEMMDeforLinearBaseModule, FEMMDeforLinearModule, FEMMDeforLinearMSModule, FEMMDeforWinklerModule (FEM machines to evaluate the matrix and vector quantities),  MatDeforModule, MatDeforElastIsoModule, MatDeforElastOrthoModule (elastic material models).","category":"page"},{"location":"guide/guide.html#Linear-deformation-FEM-machines","page":"How to guide","title":"Linear deformation FEM  machines","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"For  the base machine for linear deformation, FEMMDeforLinearBase, assumes standard isoparametric  finite elements. It evaluates  the interior integrals:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The stiffness matrix, the mass matrix.\nThe load vector corresponding to thermal strains.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Additionally:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Function to inspect  integration points.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The FEM machine FEMMDeforLinear simply stores the data required by the base FEMMDeforLinearBase.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The machine FEMMDeforWinkler is specialized for the boundary integrals for bodies  supported  on continuously distributed springs:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Compute the stiffness matrix corresponding to the springs.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The  mean-strain FEM machine FEMMDeforLinearMS implements advanced hexahedral and tetrahedral elements based on multi-field theory and energy-sampling  stabilization. It provides functions to compute:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The stiffness matrix, the mass matrix.\nThe load vector corresponding to thermal strains.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Additionally it defines:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Function to inspect  integration points.","category":"page"},{"location":"guide/guide.html#Materials-for-linear-deformation-analysis","page":"How to guide","title":"Materials for linear deformation analysis","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The module MatDeforModule provides functions to convert between vector and matrix (tensor) representations of stress and strain. Further, functions to rotate stress and strain between different coordinate systems (based upon the model-reduction type, 3-D, 2-D, or 1-D) are provided.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Currently  there are material types for isotropic and orthotropic linear elastic materials. The user may add  additional material types by deriving from AbstractMatDefor and equipping them with three methods: (1) compute the tangent moduli, (2) update the material state, (3) compute the thermal strain.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"For full generality, material types  should implement these methods for fully three-dimensional, plane strain and plane stress, 2D axially symmetric, and one-dimensional deformation models.","category":"page"},{"location":"guide/guide.html#Linear-deformation-algorithms","page":"How to guide","title":"Linear deformation algorithms","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"There are algorithms for","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Linear static analysis;\nExport  of the deformed shape for visualization;\nExport  of the nodal and elementwise stress fields for visualization;\nModal (free-vibration) analysis;\nExport  of modal shapes for visualization;\nSubspace-iteration method implementation.","category":"page"},{"location":"guide/guide.html#Model-data","page":"How to guide","title":"Model data","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Model data is a dictionary, with string keys, and arbitrary values. The documentation string for each method of an algorithm lists the required input. For instance, for the method linearstatics of the AlgoDeforLinearModule, the modeldata dictionary needs to provide key-value pairs for the finite element node set, and the regions, the boundary conditions, and so on.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The modeldata may be also supplemented with additional key-value pairs inside an algorithm and returned for further processing by other algorithms.","category":"page"},{"location":"tutorials/TEST13H_tut.html#TEST-13H:-square-plate-under-harmonic-loading","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"","category":"section"},{"location":"tutorials/TEST13H_tut.html#Description","page":"TEST 13H: square plate under harmonic loading","title":"Description","text":"","category":"section"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Harmonic forced vibration problem is solved for a homogeneous square plate, simply-supported on the circumference. This is the TEST 13H from the Abaqus v 6.12 Benchmarks manual. The test is recommended by the National Agency for Finite Element Methods and Standards (U.K.): Test 13 from NAFEMS Selected Benchmarks for Forced Vibration, R0016, March 1993.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"The plate is discretized with hexahedral solid elements. The simple support condition is approximated by distributed rollers on the boundary. Because only the out of plane displacements are prevented, the structure has three rigid body modes in the plane of the plate.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Homogeneous square plate, simply-supported on the circumference from the test 13 from NAFEMS Selected Benchmarks for Forced Vibration, R0016, March 1993. The nonzero benchmark frequencies are (in hertz): 2.377, 5.961, 5.961, 9.483, 12.133, 12.133, 15.468, 15.468 [Hz].","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"(Image: )","category":"page"},{"location":"tutorials/TEST13H_tut.html#References","page":"TEST 13H: square plate under harmonic loading","title":"References","text":"","category":"section"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"[1] NAFEMS Selected Benchmarks for Forced Vibration, R0016, March 1993.","category":"page"},{"location":"tutorials/TEST13H_tut.html#Goals","page":"TEST 13H: square plate under harmonic loading","title":"Goals","text":"","category":"section"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Show how to generate hexahedral mesh, mirroring and merging together parts.\nExecute transient simulation by the trapezoidal-rule time stepping of [1].","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"#","category":"page"},{"location":"tutorials/TEST13H_tut.html#Definitions","page":"TEST 13H: square plate under harmonic loading","title":"Definitions","text":"","category":"section"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Bring in required support.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"using FinEtools\nusing FinEtoolsDeforLinear\nusing LinearAlgebra\nusing Arpack","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"The input parameters come from [1].","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"E = 200*phun(\"GPa\");# Young's modulus\nnu = 0.3;# Poisson ratio\nrho = 8000*phun(\"kg*m^-3\");# mass density\nqmagn = 100.0*phun(\"Pa\")\nL = 10.0*phun(\"m\"); # side of the square plate\nt = 0.05*phun(\"m\"); # thickness of the square plate\nnL = 16; nt = 4;\ntolerance = t/nt/100;\nfrequencies = vcat(linearspace(0.0,2.377,20), linearspace(2.377,15.0,70))","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Compute the parameters of Rayleigh damping. For the two selected frequencies we have the relationship between the damping ratio and the Rayleigh parameters","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"xi_m=a_0omega_m+a_1omega_m","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"where m=12.  Solving for the Rayleigh parameters a_0a_1 yields:","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"zeta1 = 0.02; zeta2 = 0.02;\no1 = 2*pi*2.377;  o2 = 2*pi*15.468;\na0 = 2*(o1*o2)/(o2^2-o1^2)*(o2*zeta1-o1*zeta2);# a0\na1 = 2*(o1*o2)/(o2^2-o1^2)*(-1/o2*zeta1+1/o1*zeta2);# a1\n\n#","category":"page"},{"location":"tutorials/TEST13H_tut.html#Discrete-model","page":"TEST 13H: square plate under harmonic loading","title":"Discrete model","text":"","category":"section"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Generate the finite element domain as a block.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"fens,fes  = H8block(L, L, t, nL, nL, nt)","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Create the geometry field.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"geom = NodalField(fens.xyz)","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Create the displacement field. Note that it holds complex numbers.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"u = NodalField(zeros(FCplxFlt, size(fens.xyz,1), 3)) # displacement field","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"In order to apply the essential boundary conditions we need to select the nodes along the side faces of the plate and support them in the Z direction.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"nl = selectnode(fens, box=[0.0 0.0 -Inf Inf -Inf Inf], inflate=tolerance)\nsetebc!(u, nl, true, 3)\nnl = selectnode(fens, box=[L L -Inf Inf -Inf Inf], inflate=tolerance)\nsetebc!(u, nl, true, 3)\nnl = selectnode(fens, box=[-Inf Inf 0.0 0.0 -Inf Inf], inflate=tolerance)\nsetebc!(u, nl, true, 3)\nnl = selectnode(fens, box=[-Inf Inf L L -Inf Inf], inflate=tolerance)\nsetebc!(u, nl, true, 3)","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Those boundary conditions can now be applied to the displacement field,...","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"applyebc!(u)","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"... and the degrees of freedom can be numbered.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"numberdofs!(u)\nprintln(\"nfreedofs = $(u.nfreedofs)\")","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"The model is three-dimensional.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"MR = DeforModelRed3D\nmaterial = MatDeforElastIso(MR, rho, E, nu, 0.0)","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Given how relatively thin the plate is we choose an effective element: the mean-strain hexahedral element which is quite tolerant of the high aspect ratio.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"femm = FEMMDeforLinearMSH8(MR, IntegDomain(fes, GaussRule(3,2)), material)","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"These elements require  to know the geometry before anything else can be computed using them in a finite element machine. Hence we first need to associate the geometry with the FEMM.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"femm = associategeometry!(femm, geom)","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Now we can calculate the stiffness matrix and the mass matrix: both evaluated with the high-order Gauss rule.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"K = stiffness(femm, geom, u)\nfemm = FEMMDeforLinear(MR, IntegDomain(fes, GaussRule(3,3)), material)\nM = mass(femm, geom, u)","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"The damping matrix is a linear combination of the mass matrix and the stiffness matrix (Rayleigh model).","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"C = a0*M + a1*K","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Find the boundary finite elements on top of the plate. The uniform distributed loading will be applied to these elements.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"bdryfes = meshboundary(fes)","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Those facing up (in the positive Z direction) will be chosen:","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"topbfl = selectelem(fens, bdryfes, facing=true, direction=[0.0 0.0 1.0])","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"A base finite element model machine will be created to evaluate the loading. The force intensity is created as driven by a function, but the function really only just fills the buffer with the constant loading vector.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"function pfun(forceout::FVec{T}, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt) where {T}\n    forceout .=  [0.0, 0.0, -qmagn]\n    return forceout\nend\nfi = ForceIntensity(FFlt, 3, pfun);","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"The loading vector is lumped from the distributed uniform loading by integrating on the boundary. Hence, the dimension of the integration domain is 2.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"el1femm =  FEMMBase(IntegDomain(subset(bdryfes,topbfl), GaussRule(2,2)))\nF = distribloads(el1femm, geom, u, fi, 2);\n\n#","category":"page"},{"location":"tutorials/TEST13H_tut.html#Sweep-through-the-frequencies","page":"TEST 13H: square plate under harmonic loading","title":"Sweep through the frequencies","text":"","category":"section"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Sweep through the frequencies and calculate the complex displacement vector for each  of the frequencies from the complex balance equations of the structure.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"The entire solution will be stored  in this array:","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"U1 = zeros(FCplxFlt, u.nfreedofs, length(frequencies))\n\nprint(\"Sweeping through $(length(frequencies)) frequencies\\n\")\nfor k in 1:length(frequencies)\n    frequency = frequencies[k];\n    omega = 2*pi*frequency;\n    U1[:, k] = (-omega^2*M + 1im*omega*C + K)\\F;\n    print(\".\")\nend\nprint(\"\\n\")","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Find the midpoint of the plate bottom surface.  For this purpose the number of elements along the edge of the plate needs to be divisible by two.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"midpoint = selectnode(fens, box=[L/2 L/2 L/2 L/2 0 0], inflate=tolerance);","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Check that we found that node.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"@assert midpoint != []","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Extract the displacement component in the vertical direction (Z).","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"midpointdof = u.dofnums[midpoint, 3]\n\n#","category":"page"},{"location":"tutorials/TEST13H_tut.html#Plot-the-results","page":"TEST 13H: square plate under harmonic loading","title":"Plot the results","text":"","category":"section"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"using PlotlyJS\n\noptions = Dict(\n        :showSendToCloud=>true,\n        :plotlyServerURL=>\"https://chart-studio.plotly.com\"\n        )","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Plot the amplitude of the FRF.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"umidAmpl = abs.(U1[midpointdof, :])/phun(\"MM\")","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Define the layout of the figure.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"layout = Layout(;width=650, height=600, xaxis=attr(title=\"Frequency [Hz]\", type = \"log\"), yaxis=attr(title=\"Midpoint  displacement amplitude [mm]\", type = \"linear\"), title = \"Thin plate midpoint Amplitude FRF\")","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Create the graphs:","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"plots = cat(scatter(;x=vec(frequencies), y=vec(umidAmpl), mode=\"lines\", name = \"FEA\", line_color = \"rgb(215, 15, 15)\"); dims = 1)","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Plot the graphs:","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"pl = plot(plots, layout; options)\ndisplay(pl)","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Plot the FRF real and imaginary components.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"umidReal = real.(U1[midpointdof, :])/phun(\"MM\")\numidImag = imag.(U1[midpointdof, :])/phun(\"MM\")","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Define the layout of the figure.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"layout = Layout(;width=650, height=600, xaxis=attr(title=\"Frequency [Hz]\", type = \"log\"), yaxis=attr(title=\"Midpoint  displacement amplitude [mm]\", type = \"linear\"), title = \"Thin plate midpoint Real/Imag FRF\")","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Create the graphs:","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"plots = cat(scatter(;x=vec(frequencies), y=vec(umidReal), mode=\"markers+lines\", name = \"real\", line_color = \"rgb(215, 15, 15)\"), scatter(;x=vec(frequencies), y=vec(umidImag), mode=\"markers+lines\", name = \"imag\", line_color = \"rgb(15, 15, 215)\"); dims = 1)","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Plot the graphs:","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"pl = plot(plots, layout; options)\ndisplay(pl)","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Plot the shift of the FRF.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"umidPhase = atan.(umidImag, umidReal)/pi*180","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Define the layout of the figure.","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"layout = Layout(;width=650, height=600, xaxis=attr(title=\"Frequency [Hz]\", type = \"log\"), yaxis=attr(title=\"Phase shift [deg]\", type = \"linear\"), title = \"Thin plate midpoint FRF phase\")","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Create the graphs:","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"plots = cat(scatter(;x=vec(frequencies), y=vec(umidPhase), mode=\"lines\", name = \"phase\", line_color = \"rgb(15, 215, 15)\"),; dims = 1)","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"Plot the graphs:","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"pl = plot(plots, layout; options)\ndisplay(pl)\n\ntrue","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"","category":"page"},{"location":"tutorials/TEST13H_tut.html","page":"TEST 13H: square plate under harmonic loading","title":"TEST 13H: square plate under harmonic loading","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html#Export-to-Abaqus","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"","category":"section"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"In this example  we show how to export a model  to the finite element software Abaqus.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"The model is solved also in the example twisted_beam_algo.jl.  Here we export the model for execution in Abaqus.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"The task begins with defining the input parameters, creating the mesh, identifying the nodes  to which essential boundary conditions are to be applied,  and extracting from the boundary the surface finite elements to which the traction loading at the end of the beam is to be applied.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"This is the finite element toolkit itself.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"using FinEtools","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"The linear stress analysis application is implemented in this package.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"using FinEtoolsDeforLinear","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"We will also use specifically some functions from these modules.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"using FinEtoolsDeforLinear.AlgoDeforLinearModule\nusing FinEtools.MeshExportModule","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"Define some parameters, in consistent units.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"E = 0.29e8;\nnu = 0.22;\nW = 1.1;\nL = 12.;\nt =  0.32;\nnl = 2; nt = 1; nw = 1; ref = 2;\np =   1/W/t;","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"Loading in the Z direction. Reference (publication by Harder): 5.424e-3.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"loadv = [0;0;p]; dir = 3; uex = 0.005424534868469;","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"Loading in the Y direction. Reference (Harder): 1.754e-3. And comment the line below to obtain a solution in the other direction.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"#loadv = [0;p;0]; dir = 2; uex = 0.001753248285256;\ntolerance  = t/1000;\n\nfens,fes  = H8block(L,W,t, nl*ref,nw*ref,nt*ref)","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"Reshape the rectangular block into a twisted beam shape.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"for i = 1:count(fens)\n    let\n        a = fens.xyz[i,1]/L*(pi/2); y = fens.xyz[i,2]-(W/2); z = fens.xyz[i,3]-(t/2);\n        fens.xyz[i,:] = [fens.xyz[i,1],y*cos(a)-z*sin(a),y*sin(a)+z*cos(a)];\n    end\nend","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"Clamped face of the beam: select all the nodes in this cross-section.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"l1  = selectnode(fens; box = [0 0 -100*W 100*W -100*W 100*W], inflate  =  tolerance)","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"Traction on the opposite face","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"boundaryfes  =   meshboundary(fes);\nToplist   = selectelem(fens,boundaryfes, box =  [L L -100*W 100*W -100*W 100*W], inflate =   tolerance);","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"The tutorial proper begins here. We create the Abaqus exporter and start writing the .inp file.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"AE = AbaqusExporter(\"twisted_beam\");\nHEADING(AE, \"Twisted beam example\");","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"The  part definition is trivial: all will be defined rather for the instance of the part.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"PART(AE, \"part1\");\nEND_PART(AE);","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"The assembly will consist  of a single instance (of the empty part defined above).  The node set will be defined for the instance itself.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"ASSEMBLY(AE, \"ASSEM1\");\nINSTANCE(AE, \"INSTNC1\", \"PART1\");\nNODE(AE, fens.xyz);","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"We export the finite elements themselves.  Note that the elements  need to have  distinct numbers.  We start numbering the hexahedra at 1. The definition of the element creates simultaneously an element set  which is used below in the section assignment (and the definition of the load).","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"ELEMENT(AE, \"c3d8rh\", \"AllElements\", 1, connasarray(fes))","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"The traction is applied to surface elements.  Because the elements in the Abaqus model need to have unique numbers, we need to start from an integer  which is  the number of the solid elements plus one.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"ELEMENT(AE, \"SFM3D4\", \"TractionElements\", 1+count(fes), connasarray(subset(boundaryfes,Toplist)))","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"The nodes in the clamped cross-section are going to be grouped in the node set l1.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"NSET_NSET(AE, \"l1\", l1)","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"We define a coordinate system  (orientation of the material  coordinate system), in this example it is the global Cartesian coordinate system. The sections are defined for the solid elements of the interior and the surface elements to which the traction is applied, and the assignment to the  elements is by element set (AllElements and TractionElements). Note that for the solid section we also define reference  to hourglass control named Hourglassctl.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"ORIENTATION(AE, \"GlobalOrientation\", vec([1. 0 0]), vec([0 1. 0]));\nSOLID_SECTION(AE, \"elasticity\", \"GlobalOrientation\", \"AllElements\", \"Hourglassctl\");\nSURFACE_SECTION(AE, \"TractionElements\")","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"This concludes the definition  of the instance  and of the assembly.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"END_INSTANCE(AE);\nEND_ASSEMBLY(AE);","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"This is the definition of the isotropic elastic material.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"MATERIAL(AE, \"elasticity\")\nELASTIC(AE, E, nu)","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"The element properties for the interior hexahedra are controlled by the section-control.  In this case we are selecting enhanced hourglass stabilization (much preferable to the default  stiffness stabilization).","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"SECTION_CONTROLS(AE, \"Hourglassctl\", \"HOURGLASS=ENHANCED\")","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"The static perturbation  analysis step is defined  next.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"STEP_PERTURBATION_STATIC(AE)","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"The boundary conditions are applied directly to the node set l1.   Since the node set is defined for the instance, we need to refer to it by the qualified name ASSEM1.INSTNC1.l1.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"BOUNDARY(AE, \"ASSEM1.INSTNC1.l1\", 1)\nBOUNDARY(AE, \"ASSEM1.INSTNC1.l1\", 2)\nBOUNDARY(AE, \"ASSEM1.INSTNC1.l1\", 3)","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"The traction is applied to the surface  quadrilateral elements exported above.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"DLOAD(AE, \"ASSEM1.INSTNC1.TractionElements\", vec(loadv))","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"Now we have defined  the analysis step and the definition of the model can be concluded.","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"END_STEP(AE)\nclose(AE)","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"As quick check, here is the contents of the  exported model file:","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"@show readlines(\"twisted_beam.inp\")","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"What remains is to load the model into Abaqus and execute it as a job.  Alternatively Abaqus can be called on the input file to carry out the analysis at the command line as","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"abaqus job=twisted_beam.inp","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"The output database twisted_beam.odb can then be loaded for postprocessing, for instance from the command line as","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"abaqus viewer database=twisted_beam.odb","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"nothing","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"","category":"page"},{"location":"tutorials/twisted_beam-export-to-abaqus_tut.html","page":"Export  to Abaqus","title":"Export  to Abaqus","text":"This page was generated using Literate.jl.","category":"page"},{"location":"index.html#FinEtoolsDeforLinear-Documentation","page":"Home","title":"FinEtoolsDeforLinear Documentation","text":"","category":"section"},{"location":"index.html#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The tutorials are provided in the form of Julia scripts and Markdown files. ","category":"page"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The description of the types and the functions, organized by module and/or other logical principle.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/types.md\",\n    \"man/functions.md\",\n]\nDepth = 2","category":"page"},{"location":"index.html#Conceptual-guide","page":"Home","title":"Conceptual guide","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The construction of the toolkit is described: the composition of modules, the basic data structures, the methodology of computing quantities required in the finite element methodology, and more.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"guide/guide.md\",\n]\nDepth = 1","category":"page"}]
}
