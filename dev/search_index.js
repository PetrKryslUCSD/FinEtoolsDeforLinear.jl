var documenterSearchIndex = {"docs":
[{"location":"guide/guide.html#Guide","page":"How to guide","title":"Guide","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The FinEtools package is used here to solve linear stress analysis (deformation) problems.","category":"page"},{"location":"guide/guide.html#Modules","page":"How to guide","title":"Modules","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The package FinEtoolsDeforLinear has the following structure:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"FinEtoolsDeforLinear is the  top-level module.\nLinear deformation:  AlgoDeforLinearModule (algorithms), DeforModelRedModule (model-reduction definitions, 3D, plane strain and stress, and so on), FEMMDeforLinearBaseModule, FEMMDeforLinearModule, FEMMDeforLinearMSModule, FEMMDeforWinklerModule (FEM machines to evaluate the matrix and vector quantities),  MatDeforModule, MatDeforElastIsoModule, MatDeforElastOrthoModule (elastic material models).","category":"page"},{"location":"guide/guide.html#Linear-deformation-FEM-machines","page":"How to guide","title":"Linear deformation FEM  machines","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"For  the base machine for linear deformation, FEMMDeforLinearBase, assumes standard isoparametric  finite elements. It evaluates  the interior integrals:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The stiffness matrix, the mass matrix.\nThe load vector corresponding to thermal strains.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Additionally:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Function to inspect  integration points.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The FEM machine FEMMDeforLinear simply stores the data required by the base FEMMDeforLinearBase.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The machine FEMMDeforWinkler is specialized for the boundary integrals for bodies  supported  on continuously distributed springs:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Compute the stiffness matrix corresponding to the springs.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The  mean-strain FEM machine FEMMDeforLinearMS implements advanced hexahedral and tetrahedral elements based on multi-field theory and energy-sampling  stabilization. It provides functions to compute:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The stiffness matrix, the mass matrix.\nThe load vector corresponding to thermal strains.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Additionally it defines:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Function to inspect  integration points.","category":"page"},{"location":"guide/guide.html#Materials-for-linear-deformation-analysis","page":"How to guide","title":"Materials for linear deformation analysis","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The module MatDeforModule provides functions to convert between vector and matrix (tensor) representations of stress and strain. Further, functions to rotate stress and strain between different coordinate systems (based upon the model-reduction type, 3-D, 2-D, or 1-D) are provided.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Currently  there are material types for isotropic and orthotropic linear elastic materials. The user may add  additional material types by deriving from AbstractMatDefor and equipping them with three methods: (1) compute the tangent moduli, (2) update the material state, (3) compute the thermal strain.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"For full generality, material types  should implement these methods for fully three-dimensional, plane strain and plane stress, 2D axially symmetric, and one-dimensional deformation models.","category":"page"},{"location":"guide/guide.html#Linear-deformation-algorithms","page":"How to guide","title":"Linear deformation algorithms","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"There are algorithms for","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Linear static analysis;\nExport  of the deformed shape for visualization;\nExport  of the nodal and elementwise stress fields for visualization;\nModal (free-vibration) analysis;\nExport  of modal shapes for visualization;\nSubspace-iteration method implementation.","category":"page"},{"location":"guide/guide.html#Model-data","page":"How to guide","title":"Model data","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Model data is a dictionary, with string keys, and arbitrary values. The documentation string for each method of an algorithm lists the required input. For instance, for the method linearstatics of the AlgoDeforLinearModule, the modeldata dictionary needs to provide key-value pairs for the finite element node set, and the regions, the boundary conditions, and so on.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The modeldata may be also supplemented with additional key-value pairs inside an algorithm and returned for further processing by other algorithms.","category":"page"},{"location":"index.html#FinEtoolsDeforLinear-Documentation","page":"Home","title":"FinEtoolsDeforLinear Documentation","text":"","category":"section"},{"location":"index.html#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The tutorials are provided in the form of Julia scripts and Markdown files in a separate package. ","category":"page"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The description of the types and the functions, organized by module and/or other logical principle.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/types.md\",\n    \"man/functions.md\",\n]\nDepth = 2","category":"page"},{"location":"index.html#Conceptual-guide","page":"Home","title":"Conceptual guide","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The construction of the toolkit is described: the composition of modules, the basic data structures, the methodology of computing quantities required in the finite element methodology, and more.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"guide/guide.md\",\n]\nDepth = 1","category":"page"},{"location":"man/types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"man/types.html#FEM-machines","page":"Types","title":"FEM machines","text":"","category":"section"},{"location":"man/types.html#Linear-deformation","page":"Types","title":"Linear deformation","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtoolsDeforLinear.DeforModelRedModule, FinEtoolsDeforLinear.FEMMDeforLinearBaseModule, FinEtoolsDeforLinear.FEMMDeforLinearModule, FinEtoolsDeforLinear.FEMMDeforWinklerModule, FinEtoolsDeforLinear.FEMMDeforLinearMSModule, FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule, FinEtoolsDeforLinear.FEMMDeforLinearNICEModule, FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtoolsDeforLinear.DeforModelRedModule.AbstractDeforModelRed","page":"Types","title":"FinEtoolsDeforLinear.DeforModelRedModule.AbstractDeforModelRed","text":"AbstractDeforModelRed\n\nAbstract type of model reduction for deformation analysis.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed1D","page":"Types","title":"FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed1D","text":"DeforModelRed1D <: AbstractDeforModelRed\n\nModel reduction for 1-D models.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed2DAxisymm","page":"Types","title":"FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed2DAxisymm","text":"DeforModelRed2DAxisymm <: AbstractDeforModelRed\n\nModel reduction for 2-D axially symmetric models.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed2DStrain","page":"Types","title":"FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed2DStrain","text":"DeforModelRed2DStrain <: AbstractDeforModelRed\n\nModel reduction for 2-D plane strain models.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed2DStress","page":"Types","title":"FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed2DStress","text":"DeforModelRed2DStress <: AbstractDeforModelRed\n\nModel reduction for 2-D plane stress models.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed3D","page":"Types","title":"FinEtoolsDeforLinear.DeforModelRedModule.DeforModelRed3D","text":"DeforModelRed3D <: AbstractDeforModelRed\n\nModel reduction for 3-D models.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.AbstractFEMMDeforLinear","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.AbstractFEMMDeforLinear","text":"AbstractFEMMDeforLinear <: AbstractFEMMBase\n\nAbstract type of FEMM for linear deformation.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearModule.FEMMDeforLinear","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearModule.FEMMDeforLinear","text":"FEMMDeforLinear{MR<:AbstractDeforModelRed,  S<:AbstractFESet, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinear\n\nClass for linear deformation finite element modeling machine.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearModule.FEMMDeforLinear-Union{Tuple{M}, Tuple{F}, Tuple{S}, Tuple{MR}, Tuple{Type{MR},IntegDomain{S,F},M}} where M<:AbstractMatDeforLinearElastic where F<:Function where S<:AbstractFESet where MR<:AbstractDeforModelRed","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearModule.FEMMDeforLinear","text":"FEMMDeforLinear(mr::Type{MR}, integdomain::IntegDomain{S, F}, material::M) where {MR<:AbstractDeforModelRed, S<:AbstractFESet, F<:Function, M<:AbstractMatDeforLinearElastic}\n\nConstructor of linear deformation finite element modeling machine.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforWinklerModule.FEMMDeforWinkler","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforWinklerModule.FEMMDeforWinkler","text":"FEMMDeforWinkler{S<:AbstractFESet, F<:Function} <: AbstractFEMM\n\nType for normal spring support  (Winkler).\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS","text":"AbstractFEMMDeforLinearMS <: AbstractFEMMDeforLinear\n\nAbstract type for mean-strain linear deformation FEMM.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearMSModule.FEMMDeforLinearMSH8","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearMSModule.FEMMDeforLinearMSH8","text":"FEMMDeforLinearMSH8{MR<:AbstractDeforModelRed, S<:FESetH8, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearMS\n\nType for mean-strain linear deformation FEMM based on eight-node hexahedral elements.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearMSModule.FEMMDeforLinearMST10","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearMSModule.FEMMDeforLinearMST10","text":"FEMMDeforLinearMST10{MR<:AbstractDeforModelRed, S<:FESetT10, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearMS\n\nType for mean-strain linear deformation FEMM based on 10-node tetrahedral elements.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule.FEMMDeforSurfaceDamping","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule.FEMMDeforSurfaceDamping","text":"FEMMDeforSurfaceDamping{S<:AbstractFESet, F<:Function} <: AbstractFEMM\n\nType for surface damping model.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE","text":"AbstractFEMMDeforLinearNICE <: AbstractFEMMDeforLinear\n\nAbstract FEMM type for Nodally Integrated Continuum Elements (NICE).\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.FEMMDeforLinearNICEH8","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.FEMMDeforLinearNICEH8","text":"FEMMDeforLinearNICEH8{MR<:AbstractDeforModelRed, S<:FESetH8, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearNICE\n\nFEMM type for Nodally Integrated Continuum Elements (NICE) based on the eight-node hexahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.FEMMDeforLinearNICET4","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.FEMMDeforLinearNICET4","text":"FEMMDeforLinearNICET4{MR<:AbstractDeforModelRed, S<:FESetT4, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearNICE\n\nFEMM type for Nodally Integrated Continuum Elements (NICE) based on the 4-node tetrahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE","text":"AbstractFEMMDeforLinearESNICE <: AbstractFEMMDeforLinear\n\nAbstract FEMM type for Nodally Integrated Continuum Elements (NICE) with energy-sampling stabilization.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.FEMMDeforLinearESNICEH8","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.FEMMDeforLinearESNICEH8","text":"FEMMDeforLinearESNICEH8{MR<:AbstractDeforModelRed, S<:FESetH8, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearESNICE\n\nFEMM type for Nodally Integrated Continuum Elements (NICE) based on the 8-node hexahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.FEMMDeforLinearESNICET4","page":"Types","title":"FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.FEMMDeforLinearESNICET4","text":"FEMMDeforLinearESNICET4{MR<:AbstractDeforModelRed, S<:FESetT4, F<:Function, M<:AbstractMatDeforLinearElastic} <: AbstractFEMMDeforLinearESNICE\n\nFEMM type for Nodally Integrated Continuum Elements (NICE) based on the 4-node tetrahedron.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Material-models","page":"Types","title":"Material models","text":"","category":"section"},{"location":"man/types.html#Material-for-deformation,-base-functionality","page":"Types","title":"Material for deformation, base functionality","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtoolsDeforLinear.MatDeforModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforModule.AbstractMatDefor","page":"Types","title":"FinEtoolsDeforLinear.MatDeforModule.AbstractMatDefor","text":"AbstractMatDefor\n\nAbstract type that represents deformable materials.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Material-models-for-elasticity","page":"Types","title":"Material models for elasticity","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtoolsDeforLinear.MatDeforLinearElasticModule, FinEtoolsDeforLinear.MatDeforElastIsoModule, FinEtoolsDeforLinear.MatDeforElastOrthoModule,]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforLinearElasticModule.AbstractMatDeforLinearElastic","page":"Types","title":"FinEtoolsDeforLinear.MatDeforLinearElasticModule.AbstractMatDeforLinearElastic","text":"AbstractMatDeforLinearElastic <: AbstractMatDefor\n\nAbstract Linear Elasticity  material.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso{MR<:AbstractDeforModelRed, MTAN<:Function, MUPD<:Function, MTHS<:Function} <: AbstractMatDeforLinearElastic\n\nLinear isotropic elasticity  material.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed1D},Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed1D}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 1D models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed2DAxisymm},Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed2DAxisymm}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 2D axially symmetric models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed2DStrain},Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed2DStrain}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 2D plane strain models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed2DStress},Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed2DStress}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 2D plane stress models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed3D},Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed3D}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 3D models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Union{Tuple{MR}, Tuple{Type{MR},Float64,Float64}} where MR","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{MR}, E::FFlt, nu::FFlt) where {MR}\n\nCreate isotropic elastic material with default mass density and thermal expansion.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho{MR<:AbstractDeforModelRed,  MTAN<:Function, MUPD<:Function, MTHS<:Function} <: AbstractMatDeforLinearElastic\n\nLinear orthotropic elasticity  material.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Tuple{Type{DeforModelRed2DAxisymm},Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{DeforModelRed2DAxisymm}, mass_density::FFlt,\n\tE1::FFlt, E2::FFlt, E3::FFlt, nu12::FFlt, nu13::FFlt, nu23::FFlt,\n\tG12::FFlt, G13::FFlt, G23::FFlt, CTE1::FFlt, CTE2::FFlt, CTE3::FFlt)\n\nCreate elastic orthotropic material for 2D axially symmetric models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Tuple{Type{DeforModelRed2DStrain},Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{DeforModelRed2DStrain}, mass_density::FFlt,\n\tE1::FFlt, E2::FFlt, E3::FFlt, nu12::FFlt, nu13::FFlt, nu23::FFlt,\n\tG12::FFlt, G13::FFlt, G23::FFlt, CTE1::FFlt, CTE2::FFlt, CTE3::FFlt)\n\nCreate elastic orthotropic material for 2D plane strain models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Tuple{Type{DeforModelRed2DStress},Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{DeforModelRed2DStress}, mass_density::FFlt,\n\tE1::FFlt, E2::FFlt, E3::FFlt, nu12::FFlt, nu13::FFlt, nu23::FFlt,\n\tG12::FFlt, G13::FFlt, G23::FFlt, CTE1::FFlt, CTE2::FFlt, CTE3::FFlt)\n\nCreate elastic orthotropic material for 2D plane stress models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Tuple{Type{DeforModelRed3D},Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{DeforModelRed3D}, mass_density::FFlt,\n\tE1::FFlt, E2::FFlt, E3::FFlt, nu12::FFlt, nu13::FFlt, nu23::FFlt,\n\tG12::FFlt, G13::FFlt, G23::FFlt, CTE1::FFlt, CTE2::FFlt, CTE3::FFlt)\n\nCreate elastic orthotropic material for 3D models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Union{Tuple{MR}, Tuple{Type{MR},Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64,Float64}} where MR","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{MR}, E1::FFlt, E2::FFlt, E3::FFlt,\nnu12::FFlt, nu13::FFlt, nu23::FFlt,\nG12::FFlt, G13::FFlt, G23::FFlt) where {MR}\n\nCreate elastic orthotropic material.\n\nConvenience version with only the specification of the elastic properties.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Union{Tuple{MR}, Tuple{Type{MR},Float64,Float64,Float64,Float64}} where MR","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{MR}, mass_density::FFlt,  E::FFlt, nu::FFlt, CTE::FFlt) where {MR}\n\nCreate elastic orthotropic material which is really isotropic.\n\nConvenience version with only the specification of the elastic and thermal expansion properties.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Union{Tuple{MR}, Tuple{Type{MR},Float64,Float64}} where MR","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{MR}, E::FFlt, nu::FFlt) where {MR}\n\nCreate elastic orthotropic material which is really isotropic.\n\nConvenience version with only the specification of the elastic properties.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"man/functions.html#FEM-machines","page":"Functions","title":"FEM machines","text":"","category":"section"},{"location":"man/functions.html#Linear-deformation","page":"Functions","title":"Linear deformation","text":"","category":"section"},{"location":"man/functions.html#Model-reduction-types","page":"Functions","title":"Model reduction types","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.DeforModelRedModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.Blmat!-Tuple{Type{DeforModelRed1D},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.Blmat!","text":"Blmat!(MR::Type{DeforModelRed1D}, B::FFltMat,\n  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)\n\nCompute the strain-displacement matrix for a one-manifold element.\n\nCompute the linear, displacement independent, strain-displacement matrix for a one-manifold element.   The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim <= 3), and mdim = number of manifold dimensions (here mdim == 1).\n\nOutput\n\nB = strain-displacement matrix, where  size(B) = (nstressstrain,nnodes*dim); here nstressstrain= number of strains, dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element. The strain components are ordered as shown  in stresscomponentmap. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.Blmat!-Tuple{Type{DeforModelRed2DAxisymm},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.Blmat!","text":"Blmat!(MR::Type{DeforModelRed2DAxisymm}, B::FFltMat,\n  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)\n\nCompute the strain-displacement matrix for a two-manifold element for axially symmetric models.\n\nCompute the linear, displacement independent, strain-displacement matrix for a two-manifold element in axially-symmetric setting.   The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim <= 3), and mdim = number of manifold dimensions (here mdim == 2).\n\nOutput\n\nB = strain-displacement matrix, where  size(B) = (nstressstrain,nnodes*dim); here nstressstrain= number of strains, dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element. The strain components are ordered as shown  in stresscomponentmap. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.Blmat!-Tuple{Type{DeforModelRed2DStrain},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.Blmat!","text":"Blmat!(MR::Type{DeforModelRed2DStrain}, B::FFltMat,\n  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)\n\nCompute the strain-displacement matrix for a two-manifold element for plane-strain models.\n\nCompute the linear, displacement independent, strain-displacement matrix for a two-manifold element in plane-strain setting.   The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim <= 3), and mdim = number of manifold dimensions (here mdim == 2).\n\nOutput\n\nB = strain-displacement matrix, where  size(B) = (nstressstrain,nnodes*dim); here nstressstrain= number of strains, dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element. The strain components are ordered as shown  in stresscomponentmap. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.Blmat!-Tuple{Type{DeforModelRed2DStress},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.Blmat!","text":"Blmat!(MR::Type{DeforModelRed2DStress}, B::FFltMat,\n  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)\n\nCompute the strain-displacement matrix for a two-manifold element for plane-stress models.\n\nCompute the linear, displacement independent, strain-displacement matrix for a two-manifold element in plane-stress setting.   The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim <= 3), and mdim = number of manifold dimensions (here mdim == 2).\n\nOutput\n\nB = strain-displacement matrix, where  size(B) = (nstressstrain,nnodes*dim); here nstressstrain= number of strains, dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element. The strain components are ordered as shown  in stresscomponentmap. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.Blmat!-Tuple{Type{DeforModelRed3D},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.Blmat!","text":"Blmat!(MR::Type{DeforModelRed3D}, B::FFltMat,\n  N::FFltMat, gradN::FFltMat, c::FFltMat, Rm::FFltMat)\n\nCompute the strain-displacement matrix for a three-manifold element.\n\nCompute the linear, displacement independent, strain-displacement matrix for a three-manifold element.   The input displacements are in the global Cartesian coordinate system, the output strains are in the material coordinate system.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim == 3), and mdim = number of manifold dimensions (here mdim == 3).\n\nOutput\n\nB = strain-displacement matrix, where  size(B) = (nstressstrain,nnodes*dim); here nstressstrain= number of strains, dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element. The strain components are ordered as shown  in stresscomponentmap. The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.divmat-Tuple{Type{DeforModelRed3D},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.divmat","text":"divmat(MR::Type{DeforModelRed3D}, N::FFltMat, gradN::FFltMat, c::FFltMat)\n\nCompute the displacement divergence matrix for a three-manifold element.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim == 3), and mdim = number of manifold dimensions (here mdim == 3).\n\nOutput\n\ndivmat = displacement divergence matrix, where  size(divmat) = (1,nnodes*dim); here dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element.  The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.nstressstrain-Tuple{Type{DeforModelRed1D}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.nstressstrain","text":"nstressstrain(::Type{AbstractDeforModelRed})::FInt\n\nReturn the number of stress components involved in the balance equation (and how many strain components) are there for each model reduction type?\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.nthermstrain-Tuple{Type{DeforModelRed1D}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.nthermstrain","text":"nthermstrain(::Type{DeforModelRed1D})::FInt\n\nHow many thermal strain components are there for each model reduction type?\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.stresscomponentmap-Tuple{Type{DeforModelRed1D}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.stresscomponentmap","text":"stresscomponentmap(::Type{DeforModelRed1D})\n\nConstruct a dictionary to map from stress-component symbols to indexes.\n\nExample\n\nWhich component of the stress vector is for instance sigma_x? Do\n\njulia> comp = stresscomponentmap(DeforModelRed1D)\nDict{Symbol,Int64} with 2 entries:\n  :xx => 1\n  :x  => 1\n\njulia>\n\njulia> comp[:x]\n1\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.DeforModelRedModule.vgradmat-Tuple{Type{DeforModelRed3D},Array{Float64,2},Array{Float64,2},Array{Float64,2}}","page":"Functions","title":"FinEtoolsDeforLinear.DeforModelRedModule.vgradmat","text":"vgradmat(MR::Type{DeforModelRed3D}, N::FFltMat, gradN::FFltMat, c::FFltMat)\n\nCompute the matrix of displacement gradient in vector form for a three-manifold element.\n\nArguments\n\nN =matrix of basis function values\ngradN =matrix of basis function gradients with respect to the Cartesian coordinates in the directions of the material orientation\nc =array of spatial coordinates of the evaluation point in the global Cartesian coordinates.\nRm =orthogonal matrix with the unit basis vectors of the local material orientation coordinate system as columns. size(Rm)= (ndim,mdim), where ndim = number of spatial dimensions of the embedding space (here ndim == 3), and mdim = number of manifold dimensions (here mdim == 3).\n\nOutput\n\nvgradm = strain-displacement matrix, where  size(divmat) = (1,nnodes*dim); here dim = Number of spatial dimensions of the embedding space, and nnodes = number of finite element nodes on the element.  The matrix is passed in as a buffer, set to zero,  and filled in  with the nonzero components.  It is also returned for convenience.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Base-functionality:-Interior","page":"Functions","title":"Base functionality: Interior","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.FEMMDeforLinearBaseModule, FinEtoolsDeforLinear.FEMMDeforLinearModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FEMM}, Tuple{FEMM,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any}, Tuple{FEMM,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any,Any}} where F<:Function where T<:Number where FEMM<:AbstractFEMMDeforLinear","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::AbstractFEMMDeforLinear,\n  geom::NodalField{FFlt},  u::NodalField{T},\n  dT::NodalField{FFlt},\n  felist::FIntVec,\n  inspector::F,  idat, quantity=:Cauchy;\n  context...) where {T<:Number, F<:Function}\n\nInspect integration point quantities.\n\ngeom - reference geometry field\nu - displacement field\ndT - temperature difference field\nfelist - indexes of the finite elements that are to be inspected:    The fes to be included are: fes[felist].\ncontext    - structure: see the update!() method of the material.\ninspector - functionwith the signature       idat = inspector(idat, j, conn, x, out, loc);  where   idat - a structure or an array that the inspector may          use to maintain some state,  for instance minimum or maximum of          stress, j is the element number, conn is the element connectivity,          out is the output of the update!() method,  loc is the location          of the integration point in the reference configuration.\n\nReturn\n\nThe updated inspector data is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.infsup_gh-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.infsup_gh","text":"infsup_gh(self::AbstractFEMMDeforLinear, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the norm of the divergence of the displacement.\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.infsup_sh-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.infsup_sh","text":"infsup_sh(self::AbstractFEMMDeforLinear, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the seminorm of the displacement (square root of the sum of the squares of the derivatives of the components of displacement).\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.mass-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.mass","text":"mass(self::AbstractFEMMDeforLinear,  assembler::A,\n  geom::NodalField{FFlt},\n  u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the consistent mass matrix\n\nThis is a general routine for the abstract linear-deformation  FEMM.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness","text":"nzebcloadsstiffness(self::AbstractFEMMDeforLinear,  assembler::A,\n  geom::NodalField{FFlt},\n  u::NodalField{T}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute load vector for nonzero EBC for fixed displacement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinear, assembler::A,\n      geom::NodalField{FFlt},\n      u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.thermalstrainloads-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear,A,NodalField{Float64},NodalField{T},NodalField{Float64}}} where T<:Number where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.thermalstrainloads","text":"thermalstrainloads(self::AbstractFEMMDeforLinear, assembler::A,\n    geom::NodalField{FFlt}, u::NodalField{T},\n    dT::NodalField{FFlt}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute the thermal-strain load vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Base-functionality:-Boundary","page":"Functions","title":"Base functionality: Boundary","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.FEMMDeforWinklerModule, FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforWinklerModule.surfacenormalspringstiffness-Union{Tuple{T}, Tuple{A}, Tuple{FEMMDeforWinkler,A,NodalField{Float64},NodalField{T},Float64,SurfaceNormal}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforWinklerModule.surfacenormalspringstiffness","text":"surfacenormalspringstiffness(self::FEMMDeforWinkler, assembler::A,\n    geom::NodalField{FFlt}, u::NodalField{T},\n    springconstant::FFlt, surfacenormal::SurfaceNormal) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the stiffness matrix of surface normal spring.\n\nRationale: consider continuously distributed springs between the surface of the solid body and the 'ground', in the direction normal to the surface. If the spring coefficient becomes large, we have an approximate method of enforcing the normal displacement to the surface.gas\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule.dampingABC-Union{Tuple{T2}, Tuple{T1}, Tuple{A}, Tuple{FEMMDeforSurfaceDamping,A,NodalField{Float64},NodalField{T1},T2,SurfaceNormal}} where T2<:Number where T1<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule.dampingABC","text":"dampingABC(self::FEMMDeforSurfaceDamping, assembler::A,\n              geom::NodalField{FFlt}, u::NodalField{T1},\n              impedance::T2, surfacenormal::SurfaceNormal) where {A<:AbstractSysmatAssembler, T1<:Number, T2<:Number}\n\nCompute the damping matrix associated with absorbing boundary conditions (ABC) representation of the effect of infinite extent of inviscid fluid next to the surface.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Simple-FE-models","page":"Functions","title":"Simple FE models","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.FEMMDeforLinearModule, FinEtoolsDeforLinear.FEMMDeforWinklerModule,  FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule, ]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Advanced-FE-models","page":"Functions","title":"Advanced FE models","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.FEMMDeforLinearMSModule, FinEtoolsDeforLinear.FEMMDeforLinearNICEModule, FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F,NodalField{Float64}}} where F<:FEMMDeforLinearMSH8","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F,NodalField{Float64}}} where F<:FEMMDeforLinearMST10","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any,Any}} where F<:Function where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::FEMMDeforLinear,      geom::NodalField{FFlt},  u::NodalField{T},      dT::NodalField{FFlt},      felist::FIntVec,      inspector::F,  idat, quantity=:Cauchy;      context...) where {T<:Number, F<:Function}\n\nInspect integration point quantities.\n\nArguments\n\ngeom - reference geometry field\nu - displacement field\ndT - temperature difference field\nfelist - indexes of the finite elements that are to be inspected:   The fes to be included are: fes[felist].\ncontext    - structure: see the update!() method of the material.\ninspector - functionwith the signature      idat = inspector(idat, j, conn, x, out, loc); where  idat - a structure or an array that the inspector may         use to maintain some state,  for instance minimum or maximum of         stress, j is the element number, conn is the element connectivity,         out is the output of the update!() method,  loc is the location         of the integration point in the reference configuration.\n\nReturn\n\nThe updated inspector data is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness","text":"nzebcloadsstiffness(self::AbstractFEMMDeforLinear,  assembler::A,   geom::NodalField{FFlt},   u::NodalField{T}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute load vector for nonzero EBC for fixed displacement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearMS, assembler::A,       geom::NodalField{FFlt},       u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearMSModule.infsup_gh-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearMSModule.infsup_gh","text":"infsup_gh(self::AbstractFEMMDeforLinearMS, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the norm of the divergence of the displacement.\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearMSModule.infsup_sh-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearMSModule.infsup_sh","text":"infsup_sh(self::AbstractFEMMDeforLinearMS, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the seminorm of the displacement (square root of the sum of the squares of the derivatives of the components of displacement).\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F,NodalField{Float64}}} where F<:FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness","text":"nzebcloadsstiffness(self::AbstractFEMMDeforLinear,  assembler::A,   geom::NodalField{FFlt},   u::NodalField{T}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute load vector for nonzero EBC for fixed displacement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearNICE, assembler::A,\n  geom::NodalField{FFlt},\n  u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE,NodalField{Float64},NodalField{T}}} where T<:Number","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearNICE, geom::NodalField{FFlt},  u::NodalField{T}) where {T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F,NodalField{Float64}}} where F<:FEMMDeforLinearESNICEH8","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::F,  geom::NodalField{FFlt}) where {F<:FEMMDeforLinearESNICEH8}\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F,NodalField{Float64}}} where F<:FEMMDeforLinearESNICET4","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::F,  geom::NodalField{FFlt}) where {F<:FEMMDeforLinearESNICET4}\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any,Any}} where F<:Function where T<:Number","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::AbstractFEMMDeforLinearESNICE, geom::NodalField{FFlt},  u::NodalField{T}, dT::NodalField{FFlt}, felist::FIntVec, inspector::F,  idat, quantity=:Cauchy; context...) where {T<:Number, F<:Function}\n\nInspect integration point quantities.\n\nArguments\n\ngeom - reference geometry field\nu - displacement field\ndT - temperature difference field\nfelist - indexes of the finite elements that are to be inspected:   The fes to be included are: fes[felist].\ncontext    - structure: see the update!() method of the material.\ninspector - functionwith the signature      idat = inspector(idat, j, conn, x, out, loc); where  idat - a structure or an array that the inspector may         use to maintain some state,  for instance minimum or maximum of         stress, j is the element number, conn is the element connectivity,         out is the output of the update!() method,  loc is the location         of the integration point in the reference configuration.\n\nReturn\n\nThe updated inspector data is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysvecAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.nzebcloadsstiffness","text":"nzebcloadsstiffness(self::AbstractFEMMDeforLinear,  assembler::A,   geom::NodalField{FFlt},   u::NodalField{T}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute load vector for nonzero EBC for fixed displacement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearESNICE, assembler::A,\n  geom::NodalField{FFlt},\n  u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.infsup_gh-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.infsup_gh","text":"infsup_gh(self::AbstractFEMMDeforLinearESNICE, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the norm of the divergence of the displacement.\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.infsup_sh-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE,A,NodalField{Float64},NodalField{T}}} where T<:Number where A<:AbstractSysmatAssembler","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.infsup_sh","text":"infsup_sh(self::AbstractFEMMDeforLinearESNICE, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the seminorm of the displacement (square root of the sum of the squares of the derivatives of the components of displacement).\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Algorithms","page":"Functions","title":"Algorithms","text":"","category":"section"},{"location":"man/functions.html#Linear-deformation-2","page":"Functions","title":"Linear deformation","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.AlgoDeforLinearModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.exportdeformation-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.exportdeformation","text":"AlgoDeforLinearModule.exportdeformation(modeldata::FDataDict)\n\nAlgorithm for exporting of the deformation for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field, or\n\"us\" = array of  tuples (name, displacement field)\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = array of data dictionaries, one for       each exported file. The data is stored with the keys:\n\"file\" - names of exported file\n\"field\" - nodal or elemental field\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.exportmode-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.exportmode","text":"AlgoDeforLinearModule.exportmode(modeldata::FDataDict)\n\nAlgorithm for exporting of the mmode shape for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field\n\"W\" = Computed free-vibration eigenvectors, neigvs columns\n\"omega\" =  Computed free-vibration angular frequencies, array of length neigvs\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\"mode\" = which mode should be visualized?\n\"component\" = which component of the quantity?\n\"outputcsys\" = output coordinate system\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = see exportdeformation()\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.exportstress-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.exportstress","text":"AlgoDeforLinearModule.exportstress(modeldata::FDataDict)\n\nAlgorithm for exporting of the stress for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\"quantity\" = quantity to be exported (default :Cauchy)\n\"component\" = which component of the quantity?\n\"outputcsys\" = output coordinate system\n\"inspectormeth\" = inspector method to pass to inspectintegpoints()\n\"extrap\" = method for extrapolating from the quadrature points to the nodes within one element\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = array of data dictionaries, one for       each exported file. The data is stored with the keys:\n\"file\" - name of exported file\n\"field\" - nodal field\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.exportstresselementwise-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.exportstresselementwise","text":"AlgoDeforLinearModule.exportstresselementwise(modeldata::FDataDict)\n\nAlgorithm for exporting of the elementwise stress for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\"quantity\" = quantity to be exported (default :Cauchy)\n\"component\" = which component of the quantity?\n\"outputcsys\" = output coordinate system\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = array of data dictionaries, one for       each exported file. The data is stored with the keys:\n\"file\" - name of exported file\n\"field\" - elemental field\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.linearstatics-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.linearstatics","text":"AlgoDeforLinearModule.linearstatics(modeldata::FDataDict)\n\nAlgorithm for static linear deformation (stress) analysis.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"essential_bcs\" = array of essential boundary condition dictionaries\n\"traction_bcs\" = array of traction boundary condition dictionaries\n\"temperature_change\" = dictionary of data for temperature change\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element model machine (mandatory);\n\nFor essential boundary conditions (optional) each dictionary would hold\n\n\"displacement\" = fixed (prescribed) displacement (scalar),  or         a function with signature function w = f(x).         If this value is not given, zero displacement is assumed.\n\"component\" = which component is prescribed  (1, 2, 3)?\n\"node_list\" = list of nodes on the boundary to which the condition applies         (mandatory)\n\nFor traction boundary conditions (optional) each dictionary would hold key-value pairs\n\n\"femm\" = finite element model machine (mandatory);\n\"traction_vector\" = traction vector,  either  a constant numerical   vector, or  a function to be used to construct a ForceIntensity   object, or it could be the ForceIntensity object itself.\n\nOutput\n\nmodeldata = the dictionary on input is augmented with the keys\n\n\"geom\" = the nodal field that is the geometry\n\"u\" = the nodal field that is the computed displacement\n\"temp\" = the nodal field that is the temperature change\n\"work\" = work of the applied loads\n\"timing\" = dictionary with timing results\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.modal-Tuple{Dict{String,Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.modal","text":"AlgoDeforLinearModule.modal(modeldata::FDataDict)\n\nModal (free-vibration) analysis solver.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"essential_bcs\" = array of essential boundary condition dictionaries\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nFor essential boundary conditions (optional) each dictionary would hold\n\n\"displacement\" = fixed (prescribed) displacement (scalar): only zero     displacement is  allowed for modal analysis.\n\"component\" = which component is prescribed  (1, 2, 3)?\n\"node_list\" = list of nodes on the boundary to which the condition applies         (mandatory)\n\nControl parameters:\n\n\"neigvs\" = number of eigenvalues/eigenvectors to compute\n\"omega_shift\"= angular frequency shift for mass shifting\n\"use_lumped_mass\" = true or false?  (Default is false: consistent mass)\n\nOutput\n\nmodeldata= the dictionary on input is augmented with\n\n\"geom\" = the nodal field that is the geometry\n\"u\" = the nodal field that is the computed displacement\n\"neigvs\" = Number of computed eigenvectors\n\"W\" = Computed eigenvectors, neigvs columns\n\"omega\" =  Computed angular frequencies, array of length neigvs\n\"raw_eigenvalues\" = Raw computed eigenvalues\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.ssit-Tuple{Any,Any}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.ssit","text":"ssit(K, M; nev::Int=6, evshift::FFlt = 0.0,\n    v0::FFltMat = Array{FFlt}(0, 0),\n    tol::FFlt = 1.0e-3, maxiter::Int = 300, verbose::Bool=false)\n\nSubspace  Iteration (block inverse power) method.\n\nBlock inverse power method for k smallest eigenvalues of the generalized eigenvalue problem            K*v= lambda*M*v\n\nArguments\n\nK =  square symmetric stiffness matrix (if necessary mass-shifted),\nM =  square symmetric mass matrix,\n\nKeyword arguments\n\nv0 =  initial guess of the eigenvectors (for instance random),\nnev = the number of eigenvalues sought\ntol = relative tolerance on the eigenvalue, expressed in terms of norms of the     change of the eigenvalue estimates from iteration to iteration.\nmaxiter =  maximum number of allowed iterations\nwithrr = with Rayleigh-Ritz problem solved to improve the subspace?  (default   is false)\nverbose = verbose? (default is false)\n\nOutput\n\nlabm = computed eigenvalues,\nv = computed eigenvectors,\nnconv = number of converged eigenvalues\nniter = number of iterations taken\nnmult = ignore this output\nlamberr = eigenvalue errors, defined as  normalized  differences  of   successive  estimates of the eigenvalues\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Material-models","page":"Functions","title":"Material models","text":"","category":"section"},{"location":"man/functions.html#Material-for-deformation,-base-functionality","page":"Functions","title":"Material for deformation, base functionality","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.MatDeforModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.dett-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.dett","text":"dett(::Type{DeforModelRed2DStrain},  C::FMat{T}) where {T}\n\nCompute the determinant of a general square matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.dett-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.dett","text":"dett(::Type{DeforModelRed3D},  C::FMat{T}) where {T}\n\nCompute the determinant of a general square matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.rotstressvec!-Union{Tuple{T}, Tuple{Type{DeforModelRed1D},Array{T,1},Array{T,1},Union{Array{T,2}, LinearAlgebra.Transpose{T,Array{T,2}}} where T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.rotstressvec!","text":"rotstressvec!(::Type{DeforModelRed1D},  outstress::FVec{T},  instress::FVec{T},  Rm::_RotationMatrix) where {T}\n\nRotate the stress vector by the supplied rotation matrix.\n\nCalculate the rotation of the stress vector to the 'bar' coordinate system given by the columns of the rotation matrix Rm.\n\noutstress = output stress vector, overwritten inside\ninstress = input stress vector\nRm = columns are components of 'bar' basis vectors on the 'plain'    basis vectors\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.rotstressvec!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DAxisymm},Array{T,1},Array{T,1},Union{Array{T,2}, LinearAlgebra.Transpose{T,Array{T,2}}} where T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.rotstressvec!","text":"rotstressvec!(::Type{DeforModelRed2DAxisymm},  outstress::FVec{T},  instress::FVec{T},  Rm::_RotationMatrix) where {T}\n\nRotate the stress vector by the supplied rotation matrix.\n\nCalculate the rotation of the stress vector to the 'bar' coordinate system given by the columns of the rotation matrix Rm.\n\noutstress = output stress vector, overwritten inside\ninstress = input stress vector\nRm = columns are components of 'bar' basis vectors on the 'plain'    basis vectors\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.rotstressvec!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,1},Array{T,1},Union{Array{T,2}, LinearAlgebra.Transpose{T,Array{T,2}}} where T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.rotstressvec!","text":"rotstressvec!(::Type{DeforModelRed2DStrain},  outstress::FVec{T},  instress::FVec{T},  Rm::_RotationMatrix) where {T}\n\nRotate the stress vector by the supplied rotation matrix.\n\nCalculate the rotation of the stress vector to the 'bar' coordinate system given by the columns of the rotation matrix Rm.\n\noutstress = output stress vector, overwritten inside\ninstress = input stress vector\nRm = columns are components of 'bar' basis vectors on the 'plain'    basis vectors\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.rotstressvec!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStress},Array{T,1},Array{T,1},Union{Array{T,2}, LinearAlgebra.Transpose{T,Array{T,2}}} where T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.rotstressvec!","text":"rotstressvec!(::Type{DeforModelRed2DStress},  outstress::FVec{T},  instress::FVec{T},  Rm::_RotationMatrix) where {T}\n\nRotate the stress vector by the supplied rotation matrix.\n\nCalculate the rotation of the stress vector to the 'bar' coordinate system given by the columns of the rotation matrix Rm.\n\noutstress = output stress vector, overwritten inside\ninstress = input stress vector\nRm = columns are components of 'bar' basis vectors on the 'plain'    basis vectors\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.rotstressvec!-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,1},Array{T,1},Union{Array{T,2}, LinearAlgebra.Transpose{T,Array{T,2}}} where T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.rotstressvec!","text":"rotstressvec!(::Type{DeforModelRed3D},  outstress::FVec{T},  instress::FVec{T}, Rm::_RotationMatrix) where {T}\n\nRotate the stress vector by the supplied rotation matrix.\n\nCalculate the rotation of the stress vector to the 'bar' coordinate system given by the columns of the rotation matrix Rm.\n\noutstress = output stress vector, overwritten inside\ninstress = input stress vector\nRm = columns are components of 'bar' basis vectors on the 'plain'    basis vectors\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainttov!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,1},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainttov!","text":"strainttov!(::Type{DeforModelRed2DStrain}, v::FVec{T}, t::FMat{T}) where {T}\n\nConvert a symmetric matrix of 2x2 strain components  into a 3-component vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainttov!-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,1},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainttov!","text":"strainttov!(::Type{DeforModelRed3D}, v::FVec{T}, t::FMat{T}) where {T}\n\nConvert a symmetric matrix of 3x3 strain components  into a 6-component vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvdet-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvdet","text":"strainvdet(::Type{DeforModelRed2DStrain},  Cv::FVec{T}) where {T}\n\nCompute the determinant of a symmetric strain-like square matrix represented as a vector. Remember that the shear strain components are twice the entries of the matrix representation.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvdet-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvdet","text":"strainvdet(::Type{DeforModelRed3D},  Cv::FVec{T}) where {T}\n\nCompute the determinant of a symmetric strain-like square matrix represented as a vector. Remember that the shear strain components are twice the entries of the matrix representation.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,2},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvtot!","text":"strainvtot!(::Type{DeforModelRed2DStrain}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a strain 3-vector to a  matrix of 2x2 strain components (symmetric tensor).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,2},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvtot!","text":"strainvtot!(::Type{DeforModelRed3D}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a strain 3-vector to a  matrix of 2x2 strain components (symmetric tensor).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvtr-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvtr","text":"strainvtr(::Type{DeforModelRed2DStrain},  Cv::FVec{T}) where {T}\n\nCompute the trace of a symmetric strain-like square matrix represented as a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvtr-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvtr","text":"strainvtr(::Type{DeforModelRed3D},  Cv::FVec{T}) where {T}\n\nCompute the trace of a symmetric strain-like square matrix represented as a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressttov!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,1},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressttov!","text":"stressttov!(::Type{DeforModelRed2DStrain}, v::FVec{T}, t::FMat{T}) where {T}\n\nConvert a symmetric matrix of 2x2 stress components to a 3-component vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressttov!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStress},Array{T,1},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressttov!","text":"stressttov!(::Type{DeforModelRed2DStress}, v::FVec{T}, t::FMat{T}) where {T}\n\nConvert a symmetric matrix of 2x2 stress components to a 3-component vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressttov!-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,1},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressttov!","text":"stressttov!(::Type{DeforModelRed3D}, v::FVec{T}, t::FMat{T}) where {T}\n\nConvert a symmetric matrix of 3x3 stress components to a 6-component vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DAxisymm},Array{T,2},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressvtot!","text":"stressvtot!(::Type{DeforModelRed2DAxisymm}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a 4-vector to a  matrix of 3x3 stress components (tensor).\n\nConvert a 4-vector to a symmetric matrix of 3x3 stress components (tensor).\n\nThe stress vector components need to be ordered as:     sigmax, sigmay, sigmaz, tauxy.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain},Array{T,2},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressvtot!","text":"stressvtot!(::Type{DeforModelRed2DStrain}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a vector to a  matrix of 2x2 stress components (symmetric tensor).\n\nIf v has 4 entries, also the t[3,3] matrix entry is set.\n\nThe stress vector components need to be ordered as:     sigmax, sigmay, tauxy, sigmaz, which is the ordering used for the plane-strain model reduction.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStress},Array{T,2},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressvtot!","text":"stressvtot!(::Type{DeforModelRed2DStress}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a 3-vector to a  matrix of 2x2 stress components (symmetric tensor).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed3D},Array{T,2},Array{T,1}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressvtot!","text":"stressvtot!(::Type{DeforModelRed3D}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a 6-vector to a  matrix of 3x3 stress components (symmetric tensor).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4checksymmetry-Tuple{Any}","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4checksymmetry","text":"tens4checksymmetry(C4th)\n\nIf the fourth-order tensor of material elasticity has the full set of symmetries, return true; otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4deviator!-Union{Tuple{Array{T,4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4deviator!","text":"tens4deviator!(t::Array{T, 4}) where {T}\n\nCompute 4th-order deviator tensor.\n\nDouble contraction of a second order tensor with this fourth-order tensor produces the deviator part of the second order tensor.\n\nExample\n\nThe product of the deviator tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4deviator!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show tr((S - tr(S)/3*I) ), tr(tS)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4dot2!-Union{Tuple{T}, Tuple{Array{T,2},Array{T,4},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4dot2!","text":"tens4dot2!(R::Array{T, 2}, F::Array{T, 4}, S::Array{T, 2}) where {T}\n\nCompute the double contraction of a 4th-order and a 2nd-order tensors.\n\nnote: Note\n\n\nThe double contraction  of two second-order sensors is defined as  A:B = tr(A'*B) = A_ij B_ij\n\nThe resulting second-order tensor is first zeroed out, and then the result is accumulated.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4identity!-Union{Tuple{Array{T,4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4identity!","text":"tens4identity!(t::Array{T, 4}) where {T}\n\nCompute 4th-order identity tensor.\n\nExample\n\nThe product of the identity tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4identity!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show S - tS\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4ijkl!-Union{Tuple{FB}, Tuple{FA}, Tuple{T}, Tuple{Array{T,4},FA,FB}} where FB where FA where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4ijkl!","text":"tens4ijkl!(t::Array{T, 4}, A::FA, B::FB, op = :+) where {T, FA, FB}\n\nFill a 4th-order tensor as a dyadic product of two 2nd-order tensors.\n\nThe i,j,k,l component is given as t[i,j,k,l]=A(i,j)*B(k,l).\n\nnote: Note\n\n\nThe tensor is accumulated to. It needs to be initialized to zero, if that is desired as the initial state.\n\nExample\n\nt = fill(0.0, 3, 3, 3, 3)\ndelta = (I, J) -> I == J ? 1.0 : 0.0\ntens4ijkl!(t, delta, delta)\nS = rand(3, 3)\n@show tr(S) * I\ntS = fill(0.0, 3, 3)\n@show tens4dot2!(tS, t, S)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4ikjl!-Union{Tuple{FB}, Tuple{FA}, Tuple{T}, Tuple{Array{T,4},FA,FB}} where FB where FA where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4ikjl!","text":"tens4ikjl!(t::Array{T, 4}, A::FA, B::FB) where {T, FA, FB}\n\nFill a 4th-order tensor as a dyadic product of two 2nd-order tensors.\n\nThe i,j,k,l component is given as t[i,j,k,l]=A(i,k)*B(j,l).\n\nnote: Note\n\n\nThe tensor is accumulated to. It needs to be initialized to zero, if that is desired as the initial state.\n\nExample\n\nt = fill(0.0, 3, 3, 3, 3)\ndelta = (I, J) -> I == J ? 1.0 : 0.0\ntens4ikjl!(t, delta, delta)\nS = rand(3, 3)\n@show transpose(S) \ntS = fill(0.0, 3, 3)\n@show transpose(S) - tens4dot2!(tS, t, S)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4iljk!-Union{Tuple{FB}, Tuple{FA}, Tuple{T}, Tuple{Array{T,4},FA,FB}} where FB where FA where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4iljk!","text":"tens4iljk!(t::Array{T, 4}, A::FA, B::FB) where {T, FA, FB}\n\nFill a 4th-order tensor as a dyadic product of two 2nd-order tensors.\n\nThe i,j,k,l component is given as t[i,j,k,l]=A(i,l)*B(j,k).\n\nnote: Note\n\n\nThe tensor is accumulated to. It needs to be initialized to zero, if that is desired as the initial state.\n\nExample\n\nt = fill(0.0, 3, 3, 3, 3)\ndelta = (I, J) -> I == J ? 1.0 : 0.0\ntens4iljk!(t, delta, delta)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\n@show S - tens4dot2!(tS, t, S)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4skewor!-Union{Tuple{Array{T,4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4skewor!","text":"tens4skewor!(t::Array{T, 4}) where {T}\n\nCompute 4th-order skewor tensor.\n\nDouble contraction of a second order tensor with this fourth-order tensor produces the skew part of the second order tensor.\n\nExample\n\nThe product of the skewor tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4skewor!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show (S - S')/2 * I - tS\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4symmetrizor!-Union{Tuple{Array{T,4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4symmetrizor!","text":"tens4symmetrizor!(t::Array{T, 4}) where {T}\n\nCompute 4th-order symmetrizor tensor.\n\nDouble contraction of a second order tensor with this fourth-order tensor produces the symmetric part of the second order tensor.\n\nExample\n\nThe product of the symmetrizor tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4symmetrizor!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show (S + S')/2 * I - tS\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4symmt6x6tot!-Union{Tuple{T}, Tuple{Array{T,4},Array{T,2}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4symmt6x6tot!","text":"tens4symmt6x6tot!(ST::Array{T, 4}, M::FMat{T}) where {T}\n\nConvert a symmetric 6 x 6 matrix to a symmetric 4th-order tensor.\n\n!!! Note The order corresponds to the arrangement of the components of stress (or strain) tensor, symmetric, three-dimensional, into a 6-component  vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4symmtto6x6t!-Union{Tuple{T}, Tuple{Array{T,2},Array{T,4}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4symmtto6x6t!","text":"tens4symmtto6x6t!(M::FMat{T}, ST::Array{T, 4}) where {T}\n\nConvert a symmetric 4th-order tensor to a 6 x 6 matrix.\n\n!!! Note The order corresponds to the arrangement of the components of stress (or strain) tensor, symmetric, three-dimensional, into a 6-component  vector.\n\nExample\n\nJ=tens4_ijkl(eye(3),eye(3))\nproduces the tracor:\nT=rand(3); \nsum(diag(T))*eye(3)\nt= tens4_dot_2(J,T)\nM= tens4_symm_to_6(ST)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4tracor!-Union{Tuple{Array{T,4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4tracor!","text":"tens4tracor!(t::Array{T, 4}) where {T}\n\nCompute 4th-order tracor tensor.\n\nDouble contraction of a second order tensor with this fourth-order tensor produces the spherical part of the second order tensor.\n\nExample\n\nThe product of the tracor tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4tracor!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show tr(S) * I - tS\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4transposor!-Union{Tuple{Array{T,4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4transposor!","text":"tens4transposor!(t::Array{T, 4}) where {T}\n\nCompute 4th-order transposor tensor.\n\nExample\n\nThe product of the transposor tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4transposor!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show S' - tS\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Material-models-for-elasticity","page":"Functions","title":"Material models for elasticity","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.MatDeforLinearElasticModule, FinEtoolsDeforLinear.MatDeforElastIsoModule, FinEtoolsDeforLinear.MatDeforElastOrthoModule,]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforLinearElasticModule.tangentmoduli!-Tuple{AbstractMatDeforLinearElastic,Array{Float64,2},Float64,Float64,Array{Float64,2},Int64}","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforLinearElasticModule.tangentmoduli!","text":"tangentmoduli!(self::AbstractMatDeforLinearElastic,  D::FFltMat,  t::FFlt, dt::FFlt, loc::FFltMat, label::FInt)\n\nCalculate the material stiffness matrix.\n\nD = matrix of tangent moduli, supplied as a buffer and overwritten. Returned\n\nas output.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforLinearElasticModule.thermalstrain!","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforLinearElasticModule.thermalstrain!","text":"thermalstrain!(self::AbstractMatDeforLinearElastic, thstrain::FFltVec, dT= 0.0)\n\nCompute thermal strain from the supplied temperature increment.\n\nthstrain = thermal strain vector, supplied as buffer, returned as output.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforLinearElasticModule.update!","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforLinearElasticModule.update!","text":"update!(self::AbstractMatDeforLinearElastic,  stress::FFltVec, output::FFltVec,  strain::FFltVec, thstrain::FFltVec=zeros(6), t::FFlt= 0.0, dt::FFlt= 0.0,  loc::FFltMat=zeros(3,1), label::FInt=0, quantity=:nothing)\n\nUpdate material state.\n\nstrain = strain vector,\nthstrain = thermal strain vector,\nt = current time,\ndt = current time step,\nloc = location of the quadrature point in global Cartesian coordinates,\nlabel = label of the finite element in which the quadrature point is found.\n\nOutput\n\nstress = stress vector, allocated by the caller with a size of the number of stress and\n\nstrain components, nstressstrain. The components of the stress vector are calculated and stored in the stress vector.\n\noutput =  array which is (if necessary) allocated  in an appropriate size, filled with the output quantity, and returned.\n\n\n\n\n\n","category":"function"}]
}
