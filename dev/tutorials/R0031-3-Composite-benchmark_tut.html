<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · FinEtoolsDeforLinear.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FinEtoolsDeforLinear.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="tutorials.html">Tutorials</a></li><li><a class="tocitem" href="../guide/guide.html">How to guide</a></li><li><span class="tocitem">Types and Functions</span><ul><li><a class="tocitem" href="../man/types.html">Types</a></li><li><a class="tocitem" href="../man/functions.html">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="R0031-3-Composite-benchmark_tut.html">-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="R0031-3-Composite-benchmark_tut.html">-</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforLinear.jl/blob/master/docs/src/tutorials/R0031-3-Composite-benchmark_tut.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>R0031/3 Composite plate test</p><p>This is a test recommended by the National Agency for Finite Element Methods and Standards (U.K.): Test R0031/3 from NAFEMS publication R0031, “Composites Benchmarks,” February 1995. It is  a composite  (sandwich) plate of square shape, simply supported along all four edges. Uniform transverse loading is applied to the top skin. The modeled part is one quarter of the full plate here. The serendipity  quadratic hexahedra  are used, with full integration.</p><p>The solution  can be compared with the benchmark results  in the Abaqus manual <a href="http://130.149.89.49:2080/v6.7/books/bmk/default.htm?startat=ch04s09anf83.html">&quot;Abaqus Benchmarks Guide&quot;</a>.</p><p>We begin  by <code>using</code> the toolkit <code>FinEtools</code>.</p><pre><code class="language-julia">using FinEtools</code></pre><p>Further, we use the linear-deformation application package.</p><pre><code class="language-julia">using FinEtoolsDeforLinear</code></pre><p>The problem will be solved with a pre-packaged algorithm.</p><pre><code class="language-julia">using FinEtoolsDeforLinear.AlgoDeforLinearModule</code></pre><p>For plotting we use the following packages.</p><pre><code class="language-julia">using UnicodePlots
import Statistics: mean</code></pre><p>The material parameters are specified for an orthotropic material model.  The units are attached using the <code>phun</code> function which can take the specification of the units and spits out the numerical multiplier. Here the benchmark specifies the input parameters in the English Imperial units. The skin  material:</p><pre><code class="language-julia">E1s = 1.0e7*phun(&quot;psi&quot;)
E2s = 0.4e7*phun(&quot;psi&quot;)
E3s = 0.4e7*phun(&quot;psi&quot;)
nu12s = 0.3
nu13s = 0.3
nu23s = 0.3
G12s = 0.1875e7*phun(&quot;psi&quot;)
G13s = 0.1875e7*phun(&quot;psi&quot;)
G23s = 0.1875e7*phun(&quot;psi&quot;);</code></pre><p>The core material:</p><pre><code class="language-julia">E1c = 10.0*phun(&quot;psi&quot;)
E2c = 10.0*phun(&quot;psi&quot;)
E3c = 10e4.*phun(&quot;psi&quot;)
nu12c = 0.
nu13c = 0.
nu23c = 0.
G12c = 10.0*phun(&quot;psi&quot;)
G13c = 3.0e4*phun(&quot;psi&quot;)
G23c = 1.2e4*phun(&quot;psi&quot;);</code></pre><p>The magnitude  of the distributed uniform transfers loading is</p><pre><code class="language-julia">tmag = 100*phun(&quot;psi&quot;);</code></pre><p>Now we generate the mesh.   The sandwich plate volume is divided  into a regular Cartesian grid in the <span>$X$</span> and <span>$Y$</span> direction in the plane of the plate, and  in the thickness direction  it is divided  into three layers, with each layer again subdivided into multiple  elements.</p><pre><code class="language-julia">L = 10.0*phun(&quot;in&quot;) # side of the square plate
nL = 8 # number of elements along the side of the plate
xs = collect(linearspace(0.0, L/2, nL+1))
ys = collect(linearspace(0.0, L/2, nL+1));;</code></pre><p>The thicknesses are specified from the bottom of the plate: skin, core, and then again skin.</p><pre><code class="language-julia">ts = [0.028; 0.75; 0.028]*phun(&quot;in&quot;)
nts = [2; 3;  2]; # number of elements through the thickness for each layer</code></pre><p>The <code>H8layeredplatex</code> meshing function generates the mesh and marks the elements  with a label identifying  the layer to which they belong.  We will use the label to create separate regions, with their own separate materials.</p><pre><code class="language-julia">fens,fes = H8layeredplatex(xs, ys, ts, nts)</code></pre><p>The linear hexahedra are subsequently converted to serendipity (quadratic) elements.</p><pre><code class="language-julia">fens,fes = H8toH20(fens,fes);</code></pre><p>The model reduction  here simply says this is a fully three-dimensional model.  The two orthotropic materials are created.</p><pre><code class="language-julia">MR = DeforModelRed3D
skinmaterial = MatDeforElastOrtho(MR,
  0.0, E1s, E2s, E3s,
  nu12s, nu13s, nu23s,
  G12s, G13s, G23s,
  0.0, 0.0, 0.0)
corematerial = MatDeforElastOrtho(MR,
  0.0, E1c, E2c, E3c,
  nu12c, nu13c, nu23c,
  G12c, G13c, G23c,
  0.0, 0.0, 0.0);</code></pre><p>Now we are ready to create three material regions:  one for the bottom skin, one for the core, and one for the top skin. The selection of the finite elements assigned to each of the three regions is based on the label. Full Gauss quadrature  is used.</p><pre><code class="language-julia">rl1 = selectelem(fens, fes, label=1)
skinbot = FDataDict(&quot;femm&quot;=&gt;FEMMDeforLinear(MR,
    IntegDomain(subset(fes, rl1), GaussRule(3, 3)), skinmaterial))

rl3 = selectelem(fens, fes, label=3)
skintop = FDataDict(&quot;femm&quot;=&gt;FEMMDeforLinear(MR,
    IntegDomain(subset(fes, rl3), GaussRule(3, 3)), skinmaterial))

rl2 = selectelem(fens, fes, label=2)
core = FDataDict(&quot;femm&quot;=&gt;FEMMDeforLinear(MR,
    IntegDomain(subset(fes, rl2), GaussRule(3, 3)), corematerial));</code></pre><p>Note that since we did not specify the material coordinate system,  the default is assumed  (which is identical to the global Cartesian coordinate system).</p><pre><code class="language-julia">@show skinbot[&quot;femm&quot;].mcsys</code></pre><p>Next we select the nodes to which  essential boundary conditions  will be applied.  A node is selected  if it is within the specified box  which for the purpose of the test  is inflated in all directions by <code>tolerance</code>. The  nodes on the planes of symmetry need to be selected, and also  the nodes  along the edges (faces) to be simply supported  need to be identified.</p><pre><code class="language-julia">tolerance = 0.0001*phun(&quot;in&quot;)
lx0 = selectnode(fens, box=[0.0 0.0 -Inf Inf -Inf Inf], inflate=tolerance)
lxL2 = selectnode(fens, box=[L/2 L/2 -Inf Inf -Inf Inf], inflate=tolerance)
ly0 = selectnode(fens, box=[-Inf Inf 0.0 0.0 -Inf Inf], inflate=tolerance)
lyL2 = selectnode(fens, box=[-Inf Inf L/2 L/2 -Inf Inf], inflate=tolerance);</code></pre><p>We have four sides  of the quarter of the plate, two on each plane of symmetry, and two  along the circumference. Hence we create  four essential boundary condition definitions, one for each of the sides of the plate.</p><pre><code class="language-julia">ex0 = FDataDict( &quot;displacement&quot;=&gt;  0.0, &quot;component&quot;=&gt; 3, &quot;node_list&quot;=&gt;lx0 )
exL2 = FDataDict( &quot;displacement&quot;=&gt;  0.0, &quot;component&quot;=&gt; 1, &quot;node_list&quot;=&gt;lxL2 )
ey0 = FDataDict( &quot;displacement&quot;=&gt;  0.0, &quot;component&quot;=&gt; 3, &quot;node_list&quot;=&gt;ly0 )
eyL2 = FDataDict( &quot;displacement&quot;=&gt;  0.0, &quot;component&quot;=&gt; 2, &quot;node_list&quot;=&gt;lyL2 );</code></pre><p>The traction on the top surface of the top skin is applied to the subset  of the surface mesh of the entire domain. First we compute the  boundary mesh, and then from the boundary mesh we select the surface finite elements that  &quot;face&quot; upward (along the positive <span>$Z$</span> axis).</p><pre><code class="language-julia">bfes = meshboundary(fes)
ttopl = selectelem(fens, bfes; facing=true, direction = [0.0 0.0 1.0])
Trac = FDataDict(&quot;traction_vector&quot;=&gt;[0.0; 0.0; -tmag],
    &quot;femm&quot;=&gt;FEMMBase(IntegDomain(subset(bfes, ttopl), GaussRule(2, 3))));</code></pre><p>The model data  is composed of the  finite element nodes, an array  of the regions, an array of the essential boundary condition definitions, and  an array of  the traction (natural) boundary condition definitions.</p><pre><code class="language-julia">modeldata = FDataDict(&quot;fens&quot;=&gt;fens,
 &quot;regions&quot;=&gt;[skinbot, core, skintop], &quot;essential_bcs&quot;=&gt;[ex0, exL2, ey0, eyL2],
 &quot;traction_bcs&quot;=&gt; [Trac]
 );</code></pre><p>With the model data assembled,  we can now call the algorithm.</p><pre><code class="language-julia">modeldata = AlgoDeforLinearModule.linearstatics(modeldata);</code></pre><p>The  computed solution can now be postprocessed. The displacement is reported at the center of the plate, along the line in the direction of the loading. We select all the nodes along this line.</p><pre><code class="language-julia">u = modeldata[&quot;u&quot;]
geom = modeldata[&quot;geom&quot;]
lcenter = selectnode(fens, box=[L/2 L/2  L/2 L/2 -Inf Inf], inflate=tolerance);</code></pre><p>The variation of the displacement along this line  can be plotted  as (the bottom surface of the shell is at <span>$Z=0$</span>):</p><pre><code class="language-julia">ix = sortperm(geom.values[lcenter, 3])</code></pre><p>Plot the data</p><pre><code class="language-julia">a = lineplot(geom.values[lcenter, 3][ix], u.values[lcenter, 3][ix]./phun(&quot;in&quot;), name = &quot;cold leg&quot;, xlabel = &quot;Z coordinate [in]&quot;, ylabel = &quot;Vert displ [in]&quot;, canvas = DotCanvas)
display(a)</code></pre><p>A reasonable single number to report for the deflection at the center is the average of the displacements at the nodes at the center of the plate (-0.136348):</p><pre><code class="language-julia">cdis = mean(u.values[lcenter, 3])/phun(&quot;in&quot;);
println(&quot;Center node displacements $(cdis) [in]; NAFEMS-R0031-3 reference: –0.123 [in]&quot;)</code></pre><p>The reference displacement at the center of -0.123 [in] reported for the benchmark is evaluated from  an analytical formulation that neglects transverse  (pinching) deformation. Due to the soft core, significant pinching is observed. The solution to the benchmark  obtained in Abaqus  with incompatible hexahedral elements (with the same number of elements as in the stacked continuum shell solution) is -0.131 [in], which is close to our own solution. Hence, our own solution is probably more accurate than the reference solution because it includes an effect neglected in the benchmark solution.</p><p>The deformed shape can be investigated  visually in <code>paraview</code> (uncomment the line at the bottom if you have <code>paraview</code> in your  PATH):</p><pre><code class="language-julia">File =  &quot;NAFEMS-R0031-3-plate.vtk&quot;
vtkexportmesh(File, connasarray(fes), geom.values, FinEtools.MeshExportModule.H20;
    scalars = [(&quot;Layer&quot;, fes.label)], vectors = [(&quot;displacement&quot;, u.values)])</code></pre><p>@async run(<code>&quot;paraview.exe&quot; $File</code>);</p><p>Note that the  VTK file will contain element labels (which can help us distinguish between the layers) as scalar field, and the displacements as a vector field.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 18 August 2020 16:45">Tuesday 18 August 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
