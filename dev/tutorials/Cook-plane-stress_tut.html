<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cook panel under plane stress · FinEtoolsDeforLinear.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FinEtoolsDeforLinear.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="tutorials.html">Tutorials</a></li><li><a class="tocitem" href="../guide/guide.html">How to guide</a></li><li><span class="tocitem">Types and Functions</span><ul><li><a class="tocitem" href="../man/types.html">Types</a></li><li><a class="tocitem" href="../man/functions.html">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="Cook-plane-stress_tut.html">Cook panel under plane stress</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Cook-plane-stress_tut.html">Cook panel under plane stress</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforLinear.jl/blob/master/docs/src/tutorials/Cook-plane-stress_tut.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Cook-panel-under-plane-stress"><a class="docs-heading-anchor" href="#Cook-panel-under-plane-stress">Cook panel under plane stress</a><a id="Cook-panel-under-plane-stress-1"></a><a class="docs-heading-anchor-permalink" href="#Cook-panel-under-plane-stress" title="Permalink"></a></h1><p>In this example we investigate the well-known benchmark of a tapered panel under plane stress conditions known under the name of Cook.  The problem has been solved many times with a variety of finite element models  and hence the solution is well-known.</p><p>The problem is solved in a script.  We begin  by <code>using</code> the top-level module <code>FinEtools</code>. Further, we use the linear-deformation application package.</p><pre><code class="language-julia">using FinEtools
using FinEtoolsDeforLinear</code></pre><p>With the algorithm modules, the problem can be set up (the materials, boundary conditions, and mesh are defined) and handed off to an algorithm (in this case linear static solution).  Then for postprocessing another set of algorithms can be invoked.</p><pre><code class="language-julia">using FinEtoolsDeforLinear.AlgoDeforLinearModule</code></pre><p>A few  input parameters are defined: the material parameters. Note: the units are consistent, but unnamed.</p><pre><code class="language-julia">E = 1.0;
nu = 1.0/3;</code></pre><p>The geometry of the tapered panel.</p><pre><code class="language-julia">width = 48.0; height = 44.0; thickness  = 1.0;
free_height  = 16.0;</code></pre><p>Location of tracked  deflection is the midpoint of the loaded edge.</p><pre><code class="language-julia">Mid_edge  = [48.0, 52.0];</code></pre><p>The tapered panel is loaded along the free edge with a unit force, which is here converted to loading per unit area.</p><pre><code class="language-julia">magn = 1.0/free_height/thickness;# Magnitude of applied load</code></pre><p>For the above input parameters the converged displacement of the tip  of the tapered panel in the direction of the applied shear load is</p><pre><code class="language-julia">convutip = 23.97;</code></pre><p>The mesh is generated as a rectangular block to begin with, and then the coordinates of the nodes are tweaked into the tapered panel shape. In this case we are using quadratic triangles (T6).</p><pre><code class="language-julia">n = 10; # number of elements per side
fens,fes = T6block(width, height, n, n)</code></pre><p>Reshape the rectangle into a trapezoidal panel:</p><pre><code class="language-julia">for i = 1:count(fens)
    fens.xyz[i,2] = fens.xyz[i,2]+(fens.xyz[i,1]/width)*(height -fens.xyz[i,2]/height*(height-free_height));
end</code></pre><p>The  boundary conditions  are applied to selected finite element nodes.   The selection is based on the inclusion in a selection &quot;box&quot;.</p><pre><code class="language-julia">tolerance = minimum([width, height])/n/1000.;#Geometrical tolerance</code></pre><p>Clamped edge of the membrane</p><pre><code class="language-julia">l1 = selectnode(fens; box=[0.,0.,-Inf, Inf], inflate = tolerance);</code></pre><p>The list of the selected nodes is then used twice,  to fix the degree of freedom  in the direction 1 and  in the direction 2. The essential-boundary condition data is stored in  dictionaries: <code>ess1</code> and <code>ess2</code>.  These dictionaries  are used below to compose the computational model.</p><pre><code class="language-julia">ess1 = FDataDict(&quot;displacement&quot;=&gt;  0.0, &quot;component&quot;=&gt; 1, &quot;node_list&quot;=&gt;l1);
ess2 = FDataDict(&quot;displacement&quot;=&gt;  0.0, &quot;component&quot;=&gt; 2, &quot;node_list&quot;=&gt;l1);</code></pre><p>The traction boundary condition is applied to the finite elements on the boundary of the panel. First we generate the three-node &quot;curve&quot; elements on the entire boundary of the panel.</p><pre><code class="language-julia">boundaryfes =  meshboundary(fes);</code></pre><p>Then from these finite elements we choose the ones that are inside the box that captures the edge of the geometry to which the traction should be applied.</p><pre><code class="language-julia">Toplist  = selectelem(fens, boundaryfes, box= [width, width, -Inf, Inf ], inflate=  tolerance);</code></pre><p>To apply the traction we create a finite element model machine (FEMM). For the evaluation of the traction it is sufficient to create a  &quot;base&quot; FEMM.  It consists of the geometry data <code>IntegDomain</code> (connectivity,  integration rule, evaluation  of the basis functions  and basis function gradients with respect to the parametric coordinates). This object is composed of the list of the finite elements and  an appropriate quadrature rule (Gauss rule here).</p><pre><code class="language-julia">el1femm = FEMMBase(IntegDomain(subset(boundaryfes, Toplist), GaussRule(1, 3), thickness));</code></pre><p>The traction boundary condition is specified with a constant traction vector and the FEMM that will be used to evaluate  the load vector.</p><pre><code class="language-julia">flux1 = FDataDict(&quot;traction_vector&quot;=&gt;[0.0,+magn],
    &quot;femm&quot;=&gt;el1femm
    );</code></pre><p>We make the dictionary for the region (the interior of the domain).  The FEMM for the evaluation of the integrals over the interior of the domain (that is the stiffness matrix) and the material are needed. The geometry data  now is equipped with the  triangular  three-point rule. Note the model-reduction type which is used to dispatch to appropriate specializations of the material routines and the FEMM which needs to execute different code for different reduced-dimension models. Here the model reduction is &quot;plane stress&quot;.</p><pre><code class="language-julia">MR = DeforModelRed2DStress
material = MatDeforElastIso(MR,  0.0, E, nu, 0.0)
region1 = FDataDict(&quot;femm&quot;=&gt;FEMMDeforLinear(MR, IntegDomain(fes, TriRule(3), thickness), material));</code></pre><p>The model data is a dictionary.   In the present example it consists of the node set, the array of dictionaries for the regions, and arrays of dictionaries for each essential and natural boundary condition.</p><pre><code class="language-julia">modeldata = FDataDict(&quot;fens&quot;=&gt;fens,
 &quot;regions&quot;=&gt;[region1],
 &quot;essential_bcs&quot;=&gt;[ess1, ess2],
 &quot;traction_bcs&quot;=&gt;[flux1]
 );</code></pre><p>When the model data is defined, we simply pass it to the algorithm.</p><pre><code class="language-julia">modeldata = AlgoDeforLinearModule.linearstatics(modeldata);</code></pre><p>The model data is augmented in the algorithm by the nodal field representing the geometry and the displacement field  computed by solving the system of linear algebraic equations of equilibrium.</p><pre><code class="language-julia">u = modeldata[&quot;u&quot;];
geom = modeldata[&quot;geom&quot;];</code></pre><p>The complete information returned from the algorithm  is</p><pre><code class="language-julia">@show keys(modeldata)</code></pre><p>Now we can extract the displacement at the mid-edge node and compare to the converged (reference) value. The code below selects the node inside a very small box of the size <code>tolerance</code> which presumably contains only a single node, the one at the midpoint of the edge.</p><pre><code class="language-julia">nl = selectnode(fens, box=[Mid_edge[1],Mid_edge[1],Mid_edge[2],Mid_edge[2]],
          inflate=tolerance);
theutip = u.values[nl,:]
println(&quot;displacement =$(theutip[2]) as compared to converged $convutip&quot;)</code></pre><p>For postprocessing  we will export a VTK file  with the displacement field (vectors)  and  one scalar field (<span>$\sigma_{xy}$</span>).</p><pre><code class="language-julia">modeldata[&quot;postprocessing&quot;] = FDataDict(&quot;file&quot;=&gt;&quot;cookstress&quot;,
   &quot;quantity&quot;=&gt;:Cauchy, &quot;component&quot;=&gt;:xy);
modeldata = AlgoDeforLinearModule.exportstress(modeldata);</code></pre><p>The  attribute <code>&quot;postprocessing&quot;</code> holds additional data computed and returned by the algorithm:</p><pre><code class="language-julia">@show keys(modeldata[&quot;postprocessing&quot;])</code></pre><p>The exported data can be digested as follows: <code>modeldata[&quot;postprocessing&quot;][&quot;exported&quot;]</code> is an array of exported items.</p><pre><code class="language-julia">display(keys(modeldata[&quot;postprocessing&quot;][&quot;exported&quot;]))</code></pre><p>Each entry of the array is a dictionary:</p><pre><code class="language-julia">display(keys(modeldata[&quot;postprocessing&quot;][&quot;exported&quot;][1]))</code></pre><p>Provided we have  <code>paraview</code> in the PATH, we can bring it up  to display the exported data.</p><pre><code class="language-julia">File = modeldata[&quot;postprocessing&quot;][&quot;exported&quot;][1][&quot;file&quot;]
@async run(`&quot;paraview.exe&quot; $File`);</code></pre><p>We can also extract the minimum and maximum value of the shear stress (-0.06, and 0.12).</p><pre><code class="language-julia">display(modeldata[&quot;postprocessing&quot;][&quot;exported&quot;][1][&quot;quantity&quot;])
display(modeldata[&quot;postprocessing&quot;][&quot;exported&quot;][1][&quot;component&quot;])
fld = modeldata[&quot;postprocessing&quot;][&quot;exported&quot;][1][&quot;field&quot;]
println(&quot;$(minimum(fld.values)) $(maximum(fld.values))&quot;)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 18 August 2020 15:43">Tuesday 18 August 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
