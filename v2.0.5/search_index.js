var documenterSearchIndex = {"docs":
[{"location":"guide/guide.html#Guide","page":"How to guide","title":"Guide","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The FinEtools package is used here to solve linear stress analysis (deformation) problems.","category":"page"},{"location":"guide/guide.html#Modules","page":"How to guide","title":"Modules","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The package FinEtoolsDeforLinear has the following structure:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"FinEtoolsDeforLinear is the  top-level module.\nLinear deformation:  AlgoDeforLinearModule (algorithms), DeforModelRedModule (model-reduction definitions, 3D, plane strain and stress, and so on), FEMMDeforLinearBaseModule, FEMMDeforLinearModule, FEMMDeforLinearMSModule, FEMMDeforWinklerModule (FEM machines to evaluate the matrix and vector quantities),  MatDeforModule, MatDeforElastIsoModule, MatDeforElastOrthoModule (elastic material models).","category":"page"},{"location":"guide/guide.html#Linear-deformation-FEM-machines","page":"How to guide","title":"Linear deformation FEM  machines","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"For  the base machine for linear deformation, FEMMDeforLinearBase, assumes standard isoparametric  finite elements. It evaluates  the interior integrals:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The stiffness matrix, the mass matrix.\nThe load vector corresponding to thermal strains.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Additionally:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Function to inspect  integration points.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The FEM machine FEMMDeforLinear simply stores the data required by the base FEMMDeforLinearBase.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The machine FEMMDeforWinkler is specialized for the boundary integrals for bodies  supported  on continuously distributed springs:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Compute the stiffness matrix corresponding to the springs.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The  mean-strain FEM machine FEMMDeforLinearMS implements advanced hexahedral and tetrahedral elements based on multi-field theory and energy-sampling  stabilization. It provides functions to compute:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The stiffness matrix, the mass matrix.\nThe load vector corresponding to thermal strains.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Additionally it defines:","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Function to inspect  integration points.","category":"page"},{"location":"guide/guide.html#Materials-for-linear-deformation-analysis","page":"How to guide","title":"Materials for linear deformation analysis","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The module MatDeforModule provides functions to convert between vector and matrix (tensor) representations of stress and strain. Further, functions to rotate stress and strain between different coordinate systems (based upon the model-reduction type, 3-D, 2-D, or 1-D) are provided.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Currently  there are material types for isotropic and orthotropic linear elastic materials. The user may add  additional material types by deriving from AbstractMatDefor and equipping them with three methods: (1) compute the tangent moduli, (2) update the material state, (3) compute the thermal strain.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"For full generality, material types  should implement these methods for fully three-dimensional, plane strain and plane stress, 2D axially symmetric, and one-dimensional deformation models.","category":"page"},{"location":"guide/guide.html#Linear-deformation-algorithms","page":"How to guide","title":"Linear deformation algorithms","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"There are algorithms for","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Linear static analysis;\nExport  of the deformed shape for visualization;\nExport  of the nodal and elementwise stress fields for visualization;\nModal (free-vibration) analysis;\nExport  of modal shapes for visualization;\nSubspace-iteration method implementation.","category":"page"},{"location":"guide/guide.html#Model-data","page":"How to guide","title":"Model data","text":"","category":"section"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"Model data is a dictionary, with string keys, and arbitrary values. The documentation string for each method of an algorithm lists the required input. For instance, for the method linearstatics of the AlgoDeforLinearModule, the modeldata dictionary needs to provide key-value pairs for the finite element node set, and the regions, the boundary conditions, and so on.","category":"page"},{"location":"guide/guide.html","page":"How to guide","title":"How to guide","text":"The modeldata may be also supplemented with additional key-value pairs inside an algorithm and returned for further processing by other algorithms.","category":"page"},{"location":"index.html#FinEtoolsDeforLinear-Documentation","page":"Home","title":"FinEtoolsDeforLinear Documentation","text":"","category":"section"},{"location":"index.html#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The tutorials are provided in the form of Julia scripts and Markdown files in a separate package. ","category":"page"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The description of the types and the functions, organized by module and/or other logical principle.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/types.md\",\n    \"man/functions.md\",\n]\nDepth = 2","category":"page"},{"location":"index.html#Conceptual-guide","page":"Home","title":"Conceptual guide","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The construction of the toolkit is described: the composition of modules, the basic data structures, the methodology of computing quantities required in the finite element methodology, and more.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"guide/guide.md\",\n]\nDepth = 1","category":"page"},{"location":"man/types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"man/types.html#FEM-machines","page":"Types","title":"FEM machines","text":"","category":"section"},{"location":"man/types.html#Linear-deformation","page":"Types","title":"Linear deformation","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtoolsDeforLinear.DeforModelRedModule, FinEtoolsDeforLinear.FEMMDeforLinearBaseModule, FinEtoolsDeforLinear.FEMMDeforLinearModule, FinEtoolsDeforLinear.FEMMDeforWinklerModule, FinEtoolsDeforLinear.FEMMDeforLinearMSModule, FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule, FinEtoolsDeforLinear.FEMMDeforLinearNICEModule, FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#Material-models","page":"Types","title":"Material models","text":"","category":"section"},{"location":"man/types.html#Material-for-deformation,-base-functionality","page":"Types","title":"Material for deformation, base functionality","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtoolsDeforLinear.MatDeforModule]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforModule.AbstractMatDefor","page":"Types","title":"FinEtoolsDeforLinear.MatDeforModule.AbstractMatDefor","text":"AbstractMatDefor\n\nAbstract type that represents deformable materials.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#Material-models-for-elasticity","page":"Types","title":"Material models for elasticity","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [FinEtools, FinEtoolsDeforLinear.MatDeforLinearElasticModule, FinEtoolsDeforLinear.MatDeforElastIsoModule, FinEtoolsDeforLinear.MatDeforElastOrthoModule,]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforLinearElasticModule.AbstractMatDeforLinearElastic","page":"Types","title":"FinEtoolsDeforLinear.MatDeforLinearElasticModule.AbstractMatDeforLinearElastic","text":"AbstractMatDeforLinearElastic <: AbstractMatDefor\n\nAbstract Linear Elasticity  material.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso{MR<:AbstractDeforModelRed, MTAN<:Function, MUPD<:Function, MTHS<:Function} <: AbstractMatDeforLinearElastic\n\nLinear isotropic elasticity  material.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed1DStrain}, Vararg{Float64, 4}}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed1DStrain}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 1D models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed1DStress}, Vararg{Float64, 4}}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed1DStress}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 1D models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed2DAxisymm}, Vararg{Float64, 4}}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed2DAxisymm}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 2D axially symmetric models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed2DStrain}, Vararg{Float64, 4}}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed2DStrain}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 2D plane strain models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed2DStress}, Vararg{Float64, 4}}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed2DStress}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 2D plane stress models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Tuple{Type{DeforModelRed3D}, Vararg{Float64, 4}}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{DeforModelRed3D}, mass_density::FFlt, E::FFlt, nu::FFlt, CTE::FFlt)\n\nCreate elastic isotropic material for 3D models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso-Union{Tuple{MR}, Tuple{Type{MR}, Float64, Float64}} where MR","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastIsoModule.MatDeforElastIso","text":"MatDeforElastIso(mr::Type{MR}, E::FFlt, nu::FFlt) where {MR}\n\nCreate isotropic elastic material with default mass density and thermal expansion.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho{MR<:AbstractDeforModelRed,  MTAN<:Function, MUPD<:Function, MTHS<:Function} <: AbstractMatDeforLinearElastic\n\nLinear orthotropic elasticity  material.\n\n\n\n\n\n","category":"type"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Tuple{Type{DeforModelRed2DAxisymm}, Vararg{Float64, 13}}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{DeforModelRed2DAxisymm}, mass_density::FFlt,\n\tE1::FFlt, E2::FFlt, E3::FFlt, nu12::FFlt, nu13::FFlt, nu23::FFlt,\n\tG12::FFlt, G13::FFlt, G23::FFlt, CTE1::FFlt, CTE2::FFlt, CTE3::FFlt)\n\nCreate elastic orthotropic material for 2D axially symmetric models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Tuple{Type{DeforModelRed2DStrain}, Vararg{Float64, 13}}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{DeforModelRed2DStrain}, mass_density::FFlt,\n\tE1::FFlt, E2::FFlt, E3::FFlt, nu12::FFlt, nu13::FFlt, nu23::FFlt,\n\tG12::FFlt, G13::FFlt, G23::FFlt, CTE1::FFlt, CTE2::FFlt, CTE3::FFlt)\n\nCreate elastic orthotropic material for 2D plane strain models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Tuple{Type{DeforModelRed2DStress}, Vararg{Float64, 13}}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{DeforModelRed2DStress}, mass_density::FFlt,\n\tE1::FFlt, E2::FFlt, E3::FFlt, nu12::FFlt, nu13::FFlt, nu23::FFlt,\n\tG12::FFlt, G13::FFlt, G23::FFlt, CTE1::FFlt, CTE2::FFlt, CTE3::FFlt)\n\nCreate elastic orthotropic material for 2D plane stress models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Tuple{Type{DeforModelRed3D}, Vararg{Float64, 13}}","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{DeforModelRed3D}, mass_density::FFlt,\n\tE1::FFlt, E2::FFlt, E3::FFlt, nu12::FFlt, nu13::FFlt, nu23::FFlt,\n\tG12::FFlt, G13::FFlt, G23::FFlt, CTE1::FFlt, CTE2::FFlt, CTE3::FFlt)\n\nCreate elastic orthotropic material for 3D models.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Union{Tuple{MR}, Tuple{Type{MR}, Float64, Float64}} where MR","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{MR}, E::FFlt, nu::FFlt) where {MR}\n\nCreate elastic orthotropic material which is really isotropic.\n\nConvenience version with only the specification of the elastic properties.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Union{Tuple{MR}, Tuple{Type{MR}, Vararg{Float64, 4}}} where MR","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{MR}, mass_density::FFlt,  E::FFlt, nu::FFlt, CTE::FFlt) where {MR}\n\nCreate elastic orthotropic material which is really isotropic.\n\nConvenience version with only the specification of the elastic and thermal expansion properties.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho-Union{Tuple{MR}, Tuple{Type{MR}, Vararg{Float64, 9}}} where MR","page":"Types","title":"FinEtoolsDeforLinear.MatDeforElastOrthoModule.MatDeforElastOrtho","text":"MatDeforElastOrtho(mr::Type{MR}, E1::FFlt, E2::FFlt, E3::FFlt,\nnu12::FFlt, nu13::FFlt, nu23::FFlt,\nG12::FFlt, G13::FFlt, G23::FFlt) where {MR}\n\nCreate elastic orthotropic material.\n\nConvenience version with only the specification of the elastic properties.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"man/functions.html#FEM-machines","page":"Functions","title":"FEM machines","text":"","category":"section"},{"location":"man/functions.html#Linear-deformation","page":"Functions","title":"Linear deformation","text":"","category":"section"},{"location":"man/functions.html#Model-reduction-types","page":"Functions","title":"Model reduction types","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.DeforModelRedModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Base-functionality:-Interior","page":"Functions","title":"Base functionality: Interior","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.FEMMDeforLinearBaseModule, FinEtoolsDeforLinear.FEMMDeforLinearModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FEMM}, Tuple{FEMM, NodalField{Float64}, NodalField{T}, NodalField{Float64}, Vector{Int64}, F, Any}, Tuple{FEMM, NodalField{Float64}, NodalField{T}, NodalField{Float64}, Vector{Int64}, F, Any, Any}} where {FEMM<:AbstractFEMMDeforLinear, T<:Number, F<:Function}","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::AbstractFEMMDeforLinear,\n  geom::NodalField{FFlt},  u::NodalField{T},\n  dT::NodalField{FFlt},\n  felist::FIntVec,\n  inspector::F,  idat, quantity=:Cauchy;\n  context...) where {T<:Number, F<:Function}\n\nInspect integration point quantities.\n\ngeom - reference geometry field\nu - displacement field\ndT - temperature difference field\nfelist - indexes of the finite elements that are to be inspected:    The fes to be included are: fes[felist].\ncontext    - structure: see the update!() method of the material.\ninspector - functionwith the signature       idat = inspector(idat, j, conn, x, out, loc);  where   idat - a structure or an array that the inspector may          use to maintain some state,  for instance minimum or maximum of          stress, j is the element number, conn is the element connectivity,          out is the output of the update!() method,  loc is the location          of the integration point in the reference configuration.\n\nReturn\n\nThe updated inspector data is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.infsup_gh-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear, A, NodalField{Float64}, NodalField{T}}} where {A<:AbstractSysmatAssembler, T<:Number}","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.infsup_gh","text":"infsup_gh(self::AbstractFEMMDeforLinear, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the norm of the divergence of the displacement.\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.infsup_sh-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear, A, NodalField{Float64}, NodalField{T}}} where {A<:AbstractSysmatAssembler, T<:Number}","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.infsup_sh","text":"infsup_sh(self::AbstractFEMMDeforLinear, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the seminorm of the displacement (square root of the sum of the squares of the derivatives of the components of displacement).\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.mass-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear, A, NodalField{Float64}, NodalField{T}}} where {A<:AbstractSysmatAssembler, T<:Number}","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.mass","text":"mass(self::AbstractFEMMDeforLinear,  assembler::A,\n  geom::NodalField{FFlt},\n  u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the consistent mass matrix\n\nThis is a general routine for the abstract linear-deformation  FEMM.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear, A, NodalField{Float64}, NodalField{T}}} where {A<:AbstractSysmatAssembler, T<:Number}","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinear, assembler::A,\n      geom::NodalField{FFlt},\n      u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\nnote: Note\nThe material stiffness matrix is assumed to be the same at all the points of the domain (homogeneous material).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.thermalstrainloads-Union{Tuple{T}, Tuple{A}, Tuple{AbstractFEMMDeforLinear, A, NodalField{Float64}, NodalField{T}, NodalField{Float64}}} where {A<:AbstractSysvecAssembler, T<:Number}","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.thermalstrainloads","text":"thermalstrainloads(self::AbstractFEMMDeforLinear, assembler::A,\n    geom::NodalField{FFlt}, u::NodalField{T},\n    dT::NodalField{FFlt}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute the thermal-strain load vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Base-functionality:-Boundary","page":"Functions","title":"Base functionality: Boundary","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.FEMMDeforWinklerModule, FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforWinklerModule.surfacenormalspringstiffness-Union{Tuple{T}, Tuple{A}, Tuple{FEMMDeforWinkler, A, NodalField{Float64}, NodalField{T}, Float64, SurfaceNormal}} where {A<:AbstractSysmatAssembler, T<:Number}","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforWinklerModule.surfacenormalspringstiffness","text":"surfacenormalspringstiffness(self::FEMMDeforWinkler, assembler::A,\n    geom::NodalField{FFlt}, u::NodalField{T},\n    springconstant::FFlt, surfacenormal::SurfaceNormal) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the stiffness matrix of surface normal spring.\n\nRationale: consider continuously distributed springs between the surface of the solid body and the 'ground', in the direction normal to the surface. If the spring coefficient becomes large, we have an approximate method of enforcing the normal displacement to the surface.gas\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule.dampingABC-Union{Tuple{T2}, Tuple{T1}, Tuple{A}, Tuple{FEMMDeforSurfaceDamping, A, NodalField{Float64}, NodalField{T1}, T2, SurfaceNormal}} where {A<:AbstractSysmatAssembler, T1<:Number, T2<:Number}","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule.dampingABC","text":"dampingABC(self::FEMMDeforSurfaceDamping, assembler::A,\n              geom::NodalField{FFlt}, u::NodalField{T1},\n              impedance::T2, surfacenormal::SurfaceNormal) where {A<:AbstractSysmatAssembler, T1<:Number, T2<:Number}\n\nCompute the damping matrix associated with absorbing boundary conditions (ABC) representation of the effect of infinite extent of inviscid fluid next to the surface.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Simple-FE-models","page":"Functions","title":"Simple FE models","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.FEMMDeforLinearModule, FinEtoolsDeforLinear.FEMMDeforWinklerModule,  FinEtoolsDeforLinear.FEMMDeforSurfaceDampingModule, ]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Advanced-FE-models","page":"Functions","title":"Advanced FE models","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.FEMMDeforLinearMSModule, FinEtoolsDeforLinear.FEMMDeforLinearNICEModule, FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F, NodalField{Float64}}} where F<:FEMMDeforLinearMSH8","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F, NodalField{Float64}}} where F<:FEMMDeforLinearMST10","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS, NodalField{Float64}, NodalField{T}, NodalField{Float64}, Vector{Int64}, F, Any}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS, NodalField{Float64}, NodalField{T}, NodalField{Float64}, Vector{Int64}, F, Any, Any}} where {T<:Number, F<:Function}","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::FEMMDeforLinear,      geom::NodalField{FFlt},  u::NodalField{T},      dT::NodalField{FFlt},      felist::FIntVec,      inspector::F,  idat, quantity=:Cauchy;      context...) where {T<:Number, F<:Function}\n\nInspect integration point quantities.\n\nArguments\n\ngeom - reference geometry field\nu - displacement field\ndT - temperature difference field\nfelist - indexes of the finite elements that are to be inspected:   The fes to be included are: fes[felist].\ncontext    - structure: see the update!() method of the material.\ninspector - functionwith the signature      idat = inspector(idat, j, conn, x, out, loc); where  idat - a structure or an array that the inspector may         use to maintain some state,  for instance minimum or maximum of         stress, j is the element number, conn is the element connectivity,         out is the output of the update!() method,  loc is the location         of the integration point in the reference configuration.\n\nReturn\n\nThe updated inspector data is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS, A, NodalField{Float64}, NodalField{T}}} where {A<:AbstractSysmatAssembler, T<:Number}","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearMS, assembler::A,       geom::NodalField{FFlt},       u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearMSModule.infsup_gh-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS, A, NodalField{Float64}, NodalField{T}}} where {A<:AbstractSysmatAssembler, T<:Number}","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearMSModule.infsup_gh","text":"infsup_gh(self::AbstractFEMMDeforLinearMS, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the norm of the divergence of the displacement.\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearMSModule.infsup_sh-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS, A, NodalField{Float64}, NodalField{T}}} where {A<:AbstractSysmatAssembler, T<:Number}","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearMSModule.infsup_sh","text":"infsup_sh(self::AbstractFEMMDeforLinearMS, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the seminorm of the displacement (square root of the sum of the squares of the derivatives of the components of displacement).\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearMSModule.nzebcloadsstiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearMSModule.AbstractFEMMDeforLinearMS, A, NodalField{Float64}, NodalField{T}}} where {A<:AbstractSysvecAssembler, T<:Number}","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearMSModule.nzebcloadsstiffness","text":"nzebcloadsstiffness(self::AbstractFEMMDeforLinear,  assembler::A,   geom::NodalField{FFlt},   u::NodalField{T}) where {A<:AbstractSysvecAssembler, T<:Number}\n\nCompute load vector for nonzero EBC for fixed displacement.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F, NodalField{Float64}}} where F<:FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::FEMMAbstractBase,  geom::NodalField{FFlt})\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE, A, NodalField{Float64}, NodalField{T}}} where {A<:AbstractSysmatAssembler, T<:Number}","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearNICE, assembler::A,\n  geom::NodalField{FFlt},\n  u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearNICEModule.AbstractFEMMDeforLinearNICE, NodalField{Float64}, NodalField{T}}} where T<:Number","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearNICE, geom::NodalField{FFlt},  u::NodalField{T}) where {T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F, NodalField{Float64}}} where F<:FEMMDeforLinearESNICEH8","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::F,  geom::NodalField{FFlt}) where {F<:FEMMDeforLinearESNICEH8}\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.associategeometry!-Union{Tuple{F}, Tuple{F, NodalField{Float64}}} where F<:FEMMDeforLinearESNICET4","page":"Functions","title":"FinEtools.FEMMBaseModule.associategeometry!","text":"associategeometry!(self::F,  geom::NodalField{FFlt}) where {F<:FEMMDeforLinearESNICET4}\n\nAssociate geometry field with the FEMM.\n\nCompute the  correction factors to account for  the shape of the  elements.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE, NodalField{Float64}, NodalField{T}, NodalField{Float64}, Vector{Int64}, F, Any}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE, NodalField{Float64}, NodalField{T}, NodalField{Float64}, Vector{Int64}, F, Any, Any}} where {T<:Number, F<:Function}","page":"Functions","title":"FinEtools.FEMMBaseModule.inspectintegpoints","text":"inspectintegpoints(self::AbstractFEMMDeforLinearESNICE, geom::NodalField{FFlt},  u::NodalField{T}, dT::NodalField{FFlt}, felist::FIntVec, inspector::F,  idat, quantity=:Cauchy; context...) where {T<:Number, F<:Function}\n\nInspect integration point quantities.\n\nArguments\n\ngeom - reference geometry field\nu - displacement field\ndT - temperature difference field\nfelist - indexes of the finite elements that are to be inspected:   The fes to be included are: fes[felist].\ncontext    - structure: see the update!() method of the material.\ninspector - functionwith the signature      idat = inspector(idat, j, conn, x, out, loc); where  idat - a structure or an array that the inspector may         use to maintain some state,  for instance minimum or maximum of         stress, j is the element number, conn is the element connectivity,         out is the output of the update!() method,  loc is the location         of the integration point in the reference configuration.\n\nReturn\n\nThe updated inspector data is returned.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE, A, NodalField{Float64}, NodalField{T}}} where {A<:AbstractSysmatAssembler, T<:Number}","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearBaseModule.stiffness","text":"stiffness(self::AbstractFEMMDeforLinearESNICE, assembler::A,\n  geom::NodalField{FFlt},\n  u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute and assemble  stiffness matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.infsup_gh-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE, A, NodalField{Float64}, NodalField{T}}} where {A<:AbstractSysmatAssembler, T<:Number}","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.infsup_gh","text":"infsup_gh(self::AbstractFEMMDeforLinearESNICE, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the norm of the divergence of the displacement.\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.infsup_sh-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.AbstractFEMMDeforLinearESNICE, A, NodalField{Float64}, NodalField{T}}} where {A<:AbstractSysmatAssembler, T<:Number}","page":"Functions","title":"FinEtoolsDeforLinear.FEMMDeforLinearESNICEModule.infsup_sh","text":"infsup_sh(self::AbstractFEMMDeforLinearESNICE, assembler::A, geom::NodalField{FFlt}, u::NodalField{T}) where {A<:AbstractSysmatAssembler, T<:Number}\n\nCompute the matrix to produce the seminorm of the displacement (square root of the sum of the squares of the derivatives of the components of displacement).\n\nThis matrix is used in the numerical infsup test (Klaus-Jurgen Bathe, The inf-sup condition and its evaluation for mixed finite element methods, Computers and Structures 79 (2001) 243-252.)\n\nnote: Note\n\n\nThis computation has not been optimized in any way. It can be expected to be inefficient.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Algorithms","page":"Functions","title":"Algorithms","text":"","category":"section"},{"location":"man/functions.html#Linear-deformation-2","page":"Functions","title":"Linear deformation","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.AlgoDeforLinearModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.exportdeformation-Tuple{Dict{String, Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.exportdeformation","text":"AlgoDeforLinearModule.exportdeformation(modeldata::FDataDict)\n\nAlgorithm for exporting of the deformation for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field, or\n\"us\" = array of  tuples (name, displacement field)\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = array of data dictionaries, one for       each exported file. The data is stored with the keys:\n\"file\" - names of exported file\n\"field\" - nodal or elemental field\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.exportmode-Tuple{Dict{String, Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.exportmode","text":"AlgoDeforLinearModule.exportmode(modeldata::FDataDict)\n\nAlgorithm for exporting of the mmode shape for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field\n\"W\" = Computed free-vibration eigenvectors, neigvs columns\n\"omega\" =  Computed free-vibration angular frequencies, array of length neigvs\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\"mode\" = which mode should be visualized?\n\"component\" = which component of the quantity?\n\"outputcsys\" = output coordinate system\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = see exportdeformation()\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.exportstress-Tuple{Dict{String, Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.exportstress","text":"AlgoDeforLinearModule.exportstress(modeldata::FDataDict)\n\nAlgorithm for exporting of the stress for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\"quantity\" = quantity to be exported (default :Cauchy)\n\"component\" = which component of the quantity?\n\"outputcsys\" = output coordinate system\n\"inspectormeth\" = inspector method to pass to inspectintegpoints()\n\"extrap\" = method for extrapolating from the quadrature points to the nodes within one element\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = array of data dictionaries, one for       each exported file. The data is stored with the keys:\n\"file\" - name of exported file\n\"field\" - nodal field\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.exportstresselementwise-Tuple{Dict{String, Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.exportstresselementwise","text":"AlgoDeforLinearModule.exportstresselementwise(modeldata::FDataDict)\n\nAlgorithm for exporting of the elementwise stress for visualization in Paraview.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"geom\" = geometry field\n\"u\" = displacement field\n\"postprocessing\" = dictionary  with values for keys\n\"boundary_only\" = should only the boundary of the  regions be rendered?                   Default is render the interior.\n\"file\" = name of the  postprocessing file\n\"quantity\" = quantity to be exported (default :Cauchy)\n\"component\" = which component of the quantity?\n\"outputcsys\" = output coordinate system\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nOutput\n\nmodeldata updated with\n\nmodeldata[\"postprocessing\"][\"exported\"] = array of data dictionaries, one for       each exported file. The data is stored with the keys:\n\"file\" - name of exported file\n\"field\" - elemental field\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.linearstatics-Tuple{Dict{String, Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.linearstatics","text":"AlgoDeforLinearModule.linearstatics(modeldata::FDataDict)\n\nAlgorithm for static linear deformation (stress) analysis.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"essential_bcs\" = array of essential boundary condition dictionaries\n\"traction_bcs\" = array of traction boundary condition dictionaries\n\"temperature_change\" = dictionary of data for temperature change\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element model machine (mandatory);\n\nFor essential boundary conditions (optional) each dictionary would hold\n\n\"displacement\" = fixed (prescribed) displacement (scalar),  or         a function with signature function w = f(x).         If this value is not given, zero displacement is assumed.\n\"component\" = which component is prescribed  (1, 2, 3)?\n\"node_list\" = list of nodes on the boundary to which the condition applies         (mandatory)\n\nFor traction boundary conditions (optional) each dictionary would hold key-value pairs\n\n\"femm\" = finite element model machine (mandatory);\n\"traction_vector\" = traction vector,  either  a constant numerical   vector, or  a function to be used to construct a ForceIntensity   object, or it could be the ForceIntensity object itself.\n\nOutput\n\nmodeldata = the dictionary on input is augmented with the keys\n\n\"geom\" = the nodal field that is the geometry\n\"u\" = the nodal field that is the computed displacement\n\"temp\" = the nodal field that is the temperature change\n\"work\" = work of the applied loads\n\"timing\" = dictionary with timing results\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.AlgoDeforLinearModule.modal-Tuple{Dict{String, Any}}","page":"Functions","title":"FinEtoolsDeforLinear.AlgoDeforLinearModule.modal","text":"AlgoDeforLinearModule.modal(modeldata::FDataDict)\n\nModal (free-vibration) analysis solver.\n\nArgument\n\nmodeldata = dictionary with values for keys\n\n\"fens\"  = finite element node set\n\"regions\"  = array of region dictionaries\n\"essential_bcs\" = array of essential boundary condition dictionaries\n\nFor each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:\n\n\"femm\" = finite element mmodel machine (mandatory);\n\nFor essential boundary conditions (optional) each dictionary would hold\n\n\"displacement\" = fixed (prescribed) displacement (scalar): only zero     displacement is  allowed for modal analysis.\n\"component\" = which component is prescribed  (1, 2, 3)?\n\"node_list\" = list of nodes on the boundary to which the condition applies         (mandatory)\n\nControl parameters:\n\n\"neigvs\" = number of eigenvalues/eigenvectors to compute\n\"omega_shift\"= angular frequency shift for mass shifting\n\"use_lumped_mass\" = true or false?  (Default is false: consistent mass)\n\nOutput\n\nmodeldata= the dictionary on input is augmented with\n\n\"geom\" = the nodal field that is the geometry\n\"u\" = the nodal field that is the computed displacement\n\"neigvs\" = Number of computed eigenvectors\n\"W\" = Computed eigenvectors, neigvs columns\n\"omega\" =  Computed angular frequencies, array of length neigvs\n\"raw_eigenvalues\" = Raw computed eigenvalues\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Material-models","page":"Functions","title":"Material models","text":"","category":"section"},{"location":"man/functions.html#Material-for-deformation,-base-functionality","page":"Functions","title":"Material for deformation, base functionality","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.MatDeforModule]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.dett-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain}, Matrix{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.dett","text":"dett(::Type{DeforModelRed2DStrain},  C::FMat{T}) where {T}\n\nCompute the determinant of a general square matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.dett-Union{Tuple{T}, Tuple{Type{DeforModelRed3D}, Matrix{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.dett","text":"dett(::Type{DeforModelRed3D},  C::FMat{T}) where {T}\n\nCompute the determinant of a general square matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.rotstressvec!-Union{Tuple{T}, Tuple{Type{DeforModelRed1DStress}, Vector{T}, Vector{T}, Union{Matrix{T}, LinearAlgebra.Transpose{T, Matrix{T}}} where T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.rotstressvec!","text":"rotstressvec!(::Type{DeforModelRed1D},  outstress::FVec{T},  instress::FVec{T},  Rm::_RotationMatrix) where {T}\n\nRotate the stress vector by the supplied rotation matrix.\n\nCalculate the rotation of the stress vector to the 'bar' coordinate system given by the columns of the rotation matrix Rm.\n\noutstress = output stress vector, overwritten inside\ninstress = input stress vector\nRm = columns are components of 'bar' basis vectors on the 'plain'    basis vectors\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.rotstressvec!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DAxisymm}, Vector{T}, Vector{T}, Union{Matrix{T}, LinearAlgebra.Transpose{T, Matrix{T}}} where T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.rotstressvec!","text":"rotstressvec!(::Type{DeforModelRed2DAxisymm},  outstress::FVec{T},  instress::FVec{T},  Rm::_RotationMatrix) where {T}\n\nRotate the stress vector by the supplied rotation matrix.\n\nCalculate the rotation of the stress vector to the 'bar' coordinate system given by the columns of the rotation matrix Rm.\n\noutstress = output stress vector, overwritten inside\ninstress = input stress vector\nRm = columns are components of 'bar' basis vectors on the 'plain'    basis vectors\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.rotstressvec!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain}, Vector{T}, Vector{T}, Union{Matrix{T}, LinearAlgebra.Transpose{T, Matrix{T}}} where T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.rotstressvec!","text":"rotstressvec!(::Type{DeforModelRed2DStrain},  outstress::FVec{T},  instress::FVec{T},  Rm::_RotationMatrix) where {T}\n\nRotate the stress vector by the supplied rotation matrix.\n\nCalculate the rotation of the stress vector to the 'bar' coordinate system given by the columns of the rotation matrix Rm.\n\noutstress = output stress vector, overwritten inside\ninstress = input stress vector\nRm = columns are components of 'bar' basis vectors on the 'plain'    basis vectors\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.rotstressvec!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStress}, Vector{T}, Vector{T}, Union{Matrix{T}, LinearAlgebra.Transpose{T, Matrix{T}}} where T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.rotstressvec!","text":"rotstressvec!(::Type{DeforModelRed2DStress},  outstress::FVec{T},  instress::FVec{T},  Rm::_RotationMatrix) where {T}\n\nRotate the stress vector by the supplied rotation matrix.\n\nCalculate the rotation of the stress vector to the 'bar' coordinate system given by the columns of the rotation matrix Rm.\n\noutstress = output stress vector, overwritten inside\ninstress = input stress vector\nRm = columns are components of 'bar' basis vectors on the 'plain'    basis vectors\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.rotstressvec!-Union{Tuple{T}, Tuple{Type{DeforModelRed3D}, Vector{T}, Vector{T}, Union{Matrix{T}, LinearAlgebra.Transpose{T, Matrix{T}}} where T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.rotstressvec!","text":"rotstressvec!(::Type{DeforModelRed3D},  outstress::FVec{T},  instress::FVec{T}, Rm::_RotationMatrix) where {T}\n\nRotate the stress vector by the supplied rotation matrix.\n\nCalculate the rotation of the stress vector to the 'bar' coordinate system given by the columns of the rotation matrix Rm.\n\noutstress = output stress vector, overwritten inside\ninstress = input stress vector\nRm = columns are components of 'bar' basis vectors on the 'plain'    basis vectors\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainttov!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain}, Vector{T}, Matrix{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainttov!","text":"strainttov!(::Type{DeforModelRed2DStrain}, v::FVec{T}, t::FMat{T}) where {T}\n\nConvert a symmetric matrix of 2x2 strain components  into a 3-component vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainttov!-Union{Tuple{T}, Tuple{Type{DeforModelRed3D}, Vector{T}, Matrix{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainttov!","text":"strainttov!(::Type{DeforModelRed3D}, v::FVec{T}, t::FMat{T}) where {T}\n\nConvert a symmetric matrix of 3x3 strain components  into a 6-component vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvdet-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain}, Vector{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvdet","text":"strainvdet(::Type{DeforModelRed2DStrain},  Cv::FVec{T}) where {T}\n\nCompute the determinant of a symmetric strain-like square matrix represented as a vector. Remember that the shear strain components are twice the entries of the matrix representation.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvdet-Union{Tuple{T}, Tuple{Type{DeforModelRed3D}, Vector{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvdet","text":"strainvdet(::Type{DeforModelRed3D},  Cv::FVec{T}) where {T}\n\nCompute the determinant of a symmetric strain-like square matrix represented as a vector. Remember that the shear strain components are twice the entries of the matrix representation.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain}, Matrix{T}, Vector{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvtot!","text":"strainvtot!(::Type{DeforModelRed2DStrain}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a strain 3-vector to a  matrix of 2x2 strain components (symmetric tensor).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed3D}, Matrix{T}, Vector{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvtot!","text":"strainvtot!(::Type{DeforModelRed3D}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a strain 3-vector to a  matrix of 2x2 strain components (symmetric tensor).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvtr-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain}, Vector{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvtr","text":"strainvtr(::Type{DeforModelRed2DStrain},  Cv::FVec{T}) where {T}\n\nCompute the trace of a symmetric strain-like square matrix represented as a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.strainvtr-Union{Tuple{T}, Tuple{Type{DeforModelRed3D}, Vector{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.strainvtr","text":"strainvtr(::Type{DeforModelRed3D},  Cv::FVec{T}) where {T}\n\nCompute the trace of a symmetric strain-like square matrix represented as a vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressttov!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain}, Vector{T}, Matrix{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressttov!","text":"stressttov!(::Type{DeforModelRed2DStrain}, v::FVec{T}, t::FMat{T}) where {T}\n\nConvert a symmetric matrix of 2x2 stress components to a 3-component vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressttov!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStress}, Vector{T}, Matrix{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressttov!","text":"stressttov!(::Type{DeforModelRed2DStress}, v::FVec{T}, t::FMat{T}) where {T}\n\nConvert a symmetric matrix of 2x2 stress components to a 3-component vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressttov!-Union{Tuple{T}, Tuple{Type{DeforModelRed3D}, Vector{T}, Matrix{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressttov!","text":"stressttov!(::Type{DeforModelRed3D}, v::FVec{T}, t::FMat{T}) where {T}\n\nConvert a symmetric matrix of 3x3 stress components to a 6-component vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DAxisymm}, Matrix{T}, Vector{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressvtot!","text":"stressvtot!(::Type{DeforModelRed2DAxisymm}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a 4-vector to a  matrix of 3x3 stress components (tensor).\n\nConvert a 4-vector to a symmetric matrix of 3x3 stress components (tensor).\n\nThe stress vector components need to be ordered as:     sigmax, sigmay, sigmaz, tauxy.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStrain}, Matrix{T}, Vector{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressvtot!","text":"stressvtot!(::Type{DeforModelRed2DStrain}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a vector to a  matrix of 2x2 stress components (symmetric tensor).\n\nIf v has 4 entries, also the t[3,3] matrix entry is set.\n\nThe stress vector components need to be ordered as:     sigmax, sigmay, tauxy, sigmaz, which is the ordering used for the plane-strain model reduction.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed2DStress}, Matrix{T}, Vector{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressvtot!","text":"stressvtot!(::Type{DeforModelRed2DStress}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a 3-vector to a  matrix of 2x2 stress components (symmetric tensor).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.stressvtot!-Union{Tuple{T}, Tuple{Type{DeforModelRed3D}, Matrix{T}, Vector{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.stressvtot!","text":"stressvtot!(::Type{DeforModelRed3D}, t::FMat{T}, v::FVec{T}) where {T}\n\nConvert a 6-vector to a  matrix of 3x3 stress components (symmetric tensor).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4checksymmetry-Tuple{Any}","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4checksymmetry","text":"tens4checksymmetry(C4th)\n\nIf the fourth-order tensor of material elasticity has the full set of symmetries, return true; otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4deviator!-Union{Tuple{Array{T, 4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4deviator!","text":"tens4deviator!(t::Array{T, 4}) where {T}\n\nCompute 4th-order deviator tensor.\n\nDouble contraction of a second order tensor with this fourth-order tensor produces the deviator part of the second order tensor.\n\nExample\n\nThe product of the deviator tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4deviator!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show tr((S - tr(S)/3*I) ), tr(tS)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4dot2!-Union{Tuple{T}, Tuple{Matrix{T}, Array{T, 4}, Matrix{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4dot2!","text":"tens4dot2!(R::Array{T, 2}, F::Array{T, 4}, S::Array{T, 2}) where {T}\n\nCompute the double contraction of a 4th-order and a 2nd-order tensors.\n\nnote: Note\n\n\nThe double contraction  of two second-order sensors is defined as  A:B = tr(A'*B) = A_ij B_ij\n\nThe resulting second-order tensor is first zeroed out, and then the result is accumulated.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4identity!-Union{Tuple{Array{T, 4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4identity!","text":"tens4identity!(t::Array{T, 4}) where {T}\n\nCompute 4th-order identity tensor.\n\nExample\n\nThe product of the identity tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4identity!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show S - tS\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4ijkl!-Union{Tuple{FB}, Tuple{FA}, Tuple{T}, Tuple{Array{T, 4}, FA, FB}} where {T, FA, FB}","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4ijkl!","text":"tens4ijkl!(t::Array{T, 4}, A::FA, B::FB, op = :+) where {T, FA, FB}\n\nFill a 4th-order tensor as a dyadic product of two 2nd-order tensors.\n\nThe i,j,k,l component is given as t[i,j,k,l]=A(i,j)*B(k,l).\n\nnote: Note\n\n\nThe tensor is accumulated to. It needs to be initialized to zero, if that is desired as the initial state.\n\nExample\n\nt = fill(0.0, 3, 3, 3, 3)\ndelta = (I, J) -> I == J ? 1.0 : 0.0\ntens4ijkl!(t, delta, delta)\nS = rand(3, 3)\n@show tr(S) * I\ntS = fill(0.0, 3, 3)\n@show tens4dot2!(tS, t, S)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4ikjl!-Union{Tuple{FB}, Tuple{FA}, Tuple{T}, Tuple{Array{T, 4}, FA, FB}} where {T, FA, FB}","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4ikjl!","text":"tens4ikjl!(t::Array{T, 4}, A::FA, B::FB) where {T, FA, FB}\n\nFill a 4th-order tensor as a dyadic product of two 2nd-order tensors.\n\nThe i,j,k,l component is given as t[i,j,k,l]=A(i,k)*B(j,l).\n\nnote: Note\n\n\nThe tensor is accumulated to. It needs to be initialized to zero, if that is desired as the initial state.\n\nExample\n\nt = fill(0.0, 3, 3, 3, 3)\ndelta = (I, J) -> I == J ? 1.0 : 0.0\ntens4ikjl!(t, delta, delta)\nS = rand(3, 3)\n@show transpose(S) \ntS = fill(0.0, 3, 3)\n@show transpose(S) - tens4dot2!(tS, t, S)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4iljk!-Union{Tuple{FB}, Tuple{FA}, Tuple{T}, Tuple{Array{T, 4}, FA, FB}} where {T, FA, FB}","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4iljk!","text":"tens4iljk!(t::Array{T, 4}, A::FA, B::FB) where {T, FA, FB}\n\nFill a 4th-order tensor as a dyadic product of two 2nd-order tensors.\n\nThe i,j,k,l component is given as t[i,j,k,l]=A(i,l)*B(j,k).\n\nnote: Note\n\n\nThe tensor is accumulated to. It needs to be initialized to zero, if that is desired as the initial state.\n\nExample\n\nt = fill(0.0, 3, 3, 3, 3)\ndelta = (I, J) -> I == J ? 1.0 : 0.0\ntens4iljk!(t, delta, delta)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\n@show S - tens4dot2!(tS, t, S)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4skewor!-Union{Tuple{Array{T, 4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4skewor!","text":"tens4skewor!(t::Array{T, 4}) where {T}\n\nCompute 4th-order skewor tensor.\n\nDouble contraction of a second order tensor with this fourth-order tensor produces the skew part of the second order tensor.\n\nExample\n\nThe product of the skewor tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4skewor!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show (S - S')/2 * I - tS\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4symmetrizor!-Union{Tuple{Array{T, 4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4symmetrizor!","text":"tens4symmetrizor!(t::Array{T, 4}) where {T}\n\nCompute 4th-order symmetrizor tensor.\n\nDouble contraction of a second order tensor with this fourth-order tensor produces the symmetric part of the second order tensor.\n\nExample\n\nThe product of the symmetrizor tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4symmetrizor!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show (S + S')/2 * I - tS\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4symmt6x6tot!-Union{Tuple{T}, Tuple{Array{T, 4}, Matrix{T}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4symmt6x6tot!","text":"tens4symmt6x6tot!(ST::Array{T, 4}, M::FMat{T}) where {T}\n\nConvert a symmetric 6 x 6 matrix to a symmetric 4th-order tensor.\n\n!!! Note The order corresponds to the arrangement of the components of stress (or strain) tensor, symmetric, three-dimensional, into a 6-component  vector.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4symmtto6x6t!-Union{Tuple{T}, Tuple{Matrix{T}, Array{T, 4}}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4symmtto6x6t!","text":"tens4symmtto6x6t!(M::FMat{T}, ST::Array{T, 4}) where {T}\n\nConvert a symmetric 4th-order tensor to a 6 x 6 matrix.\n\n!!! Note The order corresponds to the arrangement of the components of stress (or strain) tensor, symmetric, three-dimensional, into a 6-component  vector.\n\nExample\n\nJ=tens4_ijkl(eye(3),eye(3))\nproduces the tracor:\nT=rand(3); \nsum(diag(T))*eye(3)\nt= tens4_dot_2(J,T)\nM= tens4_symm_to_6(ST)\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4tracor!-Union{Tuple{Array{T, 4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4tracor!","text":"tens4tracor!(t::Array{T, 4}) where {T}\n\nCompute 4th-order tracor tensor.\n\nDouble contraction of a second order tensor with this fourth-order tensor produces the spherical part of the second order tensor.\n\nExample\n\nThe product of the tracor tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4tracor!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show tr(S) * I - tS\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforModule.tens4transposor!-Union{Tuple{Array{T, 4}}, Tuple{T}} where T","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforModule.tens4transposor!","text":"tens4transposor!(t::Array{T, 4}) where {T}\n\nCompute 4th-order transposor tensor.\n\nExample\n\nThe product of the transposor tensor with the second-order tensor S is \n\nt = fill(0.0, 3, 3, 3, 3)\ntens4transposor!(t)\nS = rand(3, 3)\ntS = fill(0.0, 3, 3)\ntens4dot2!(tS, t, S)\n@show S' - tS\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Material-models-for-elasticity","page":"Functions","title":"Material models for elasticity","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [FinEtools, FinEtoolsDeforLinear.MatDeforLinearElasticModule, FinEtoolsDeforLinear.MatDeforElastIsoModule, FinEtoolsDeforLinear.MatDeforElastOrthoModule,]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforLinearElasticModule.tangentmoduli!-Tuple{AbstractMatDeforLinearElastic, Matrix{Float64}, Float64, Float64, Matrix{Float64}, Int64}","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforLinearElasticModule.tangentmoduli!","text":"tangentmoduli!(self::AbstractMatDeforLinearElastic,  D::FFltMat,  t::FFlt, dt::FFlt, loc::FFltMat, label::FInt)\n\nCalculate the material stiffness matrix.\n\nD = matrix of tangent moduli, supplied as a buffer and overwritten. Returned\n\nas output.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforLinearElasticModule.thermalstrain!","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforLinearElasticModule.thermalstrain!","text":"thermalstrain!(self::AbstractMatDeforLinearElastic, thstrain::FFltVec, dT= 0.0)\n\nCompute thermal strain from the supplied temperature increment.\n\nthstrain = thermal strain vector, supplied as buffer, returned as output.\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#FinEtoolsDeforLinear.MatDeforLinearElasticModule.update!","page":"Functions","title":"FinEtoolsDeforLinear.MatDeforLinearElasticModule.update!","text":"update!(self::AbstractMatDeforLinearElastic,  stress::FFltVec, output::FFltVec,  strain::FFltVec, thstrain::FFltVec=zeros(6), t::FFlt= 0.0, dt::FFlt= 0.0,  loc::FFltMat=zeros(3,1), label::FInt=0, quantity=:nothing)\n\nUpdate material state.\n\nstrain = strain vector,\nthstrain = thermal strain vector,\nt = current time,\ndt = current time step,\nloc = location of the quadrature point in global Cartesian coordinates,\nlabel = label of the finite element in which the quadrature point is found.\n\nOutput\n\nstress = stress vector, allocated by the caller with a size of the number of stress and\n\nstrain components, nstressstrain. The components of the stress vector are calculated and stored in the stress vector.\n\noutput =  array which is (if necessary) allocated  in an appropriate size, filled with the output quantity, and returned.\n\n\n\n\n\n","category":"function"}]
}
